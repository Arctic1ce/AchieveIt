{"ast":null,"code":"import { useMultipleSelectionState as $58Phs$useMultipleSelectionState, SelectionManager as $58Phs$SelectionManager } from \"@react-stately/selection\";\nimport { useMemo as $58Phs$useMemo, useCallback as $58Phs$useCallback, useRef as $58Phs$useRef, useEffect as $58Phs$useEffect } from \"react\";\nimport { useCollection as $58Phs$useCollection } from \"@react-stately/collections\";\nimport { useControlledState as $58Phs$useControlledState } from \"@react-stately/utils\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n    * Copyright 2020 Adobe. All rights reserved.\n    * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License. You may obtain a copy\n    * of the License at http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software distributed under\n    * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n    * OF ANY KIND, either express or implied. See the License for the specific language\n    * governing permissions and limitations under the License.\n    */ /*\n       * Copyright 2020 Adobe. All rights reserved.\n       * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n       * you may not use this file except in compliance with the License. You may obtain a copy\n       * of the License at http://www.apache.org/licenses/LICENSE-2.0\n       *\n       * Unless required by applicable law or agreed to in writing, software distributed under\n       * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n       * OF ANY KIND, either express or implied. See the License for the specific language\n       * governing permissions and limitations under the License.\n       */\nclass $a02d57049d202695$export$d085fb9e920b5ca7 {\n  *[Symbol.iterator]() {\n    yield* this.iterable;\n  }\n  get size() {\n    return this.keyMap.size;\n  }\n  getKeys() {\n    return this.keyMap.keys();\n  }\n  getKeyBefore(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n  getKeyAfter(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n  getFirstKey() {\n    return this.firstKey;\n  }\n  getLastKey() {\n    return this.lastKey;\n  }\n  getItem(key) {\n    return this.keyMap.get(key);\n  }\n  at(idx) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n  getChildren(key) {\n    let node = this.keyMap.get(key);\n    return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n  }\n  constructor(nodes) {\n    this.keyMap = new Map();\n    this.iterable = nodes;\n    let visit = node => {\n      this.keyMap.set(node.key, node);\n      if (node.childNodes && node.type === \"section\") for (let child of node.childNodes) visit(child);\n    };\n    for (let node of nodes) visit(node);\n    let last;\n    let index = 0;\n    for (let [key, node] of this.keyMap) {\n      if (last) {\n        last.nextKey = key;\n        node.prevKey = last.key;\n      } else {\n        this.firstKey = key;\n        node.prevKey = undefined;\n      }\n      if (node.type === \"item\") node.index = index++;\n      last = node;\n      // Set nextKey as undefined since this might be the last node\n      // If it isn't the last node, last.nextKey will properly set at start of new loop\n      last.nextKey = undefined;\n    }\n    this.lastKey = last === null || last === void 0 ? void 0 : last.key;\n  }\n}\nfunction $e72dd72e1c76a225$export$2f645645f7bca764(props) {\n  let {\n    filter: filter\n  } = props;\n  let selectionState = (0, $58Phs$useMultipleSelectionState)(props);\n  let disabledKeys = (0, $58Phs$useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);\n  let factory = (0, $58Phs$useCallback)(nodes => filter ? new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(filter(nodes)) : new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(nodes), [filter]);\n  let context = (0, $58Phs$useMemo)(() => ({\n    suppressTextValueWarning: props.suppressTextValueWarning\n  }), [props.suppressTextValueWarning]);\n  let collection = (0, $58Phs$useCollection)(props, factory, context);\n  let selectionManager = (0, $58Phs$useMemo)(() => new (0, $58Phs$SelectionManager)(collection, selectionState), [collection, selectionState]);\n  // Reset focused key if that item is deleted from the collection.\n  const cachedCollection = (0, $58Phs$useRef)(null);\n  (0, $58Phs$useEffect)(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      const startItem = cachedCollection.current.getItem(selectionState.focusedKey);\n      const cachedItemNodes = [...cachedCollection.current.getKeys()].map(key => {\n        const itemNode = cachedCollection.current.getItem(key);\n        return itemNode.type === \"item\" ? itemNode : null;\n      }).filter(node => node !== null);\n      const itemNodes = [...collection.getKeys()].map(key => {\n        const itemNode = collection.getItem(key);\n        return itemNode.type === \"item\" ? itemNode : null;\n      }).filter(node => node !== null);\n      const diff = cachedItemNodes.length - itemNodes.length;\n      let index = Math.min(diff > 1 ? Math.max(startItem.index - diff + 1, 0) : startItem.index, itemNodes.length - 1);\n      let newNode;\n      while (index >= 0) {\n        if (!selectionManager.isDisabled(itemNodes[index].key)) {\n          newNode = itemNodes[index];\n          break;\n        }\n        // Find next, not disabled item.\n        if (index < itemNodes.length - 1) index++;else {\n          if (index > startItem.index) index = startItem.index;\n          index--;\n        }\n      }\n      selectionState.setFocusedKey(newNode ? newNode.key : null);\n    }\n    cachedCollection.current = collection;\n  }, [collection, selectionManager, selectionState, selectionState.focusedKey]);\n  return {\n    collection: collection,\n    disabledKeys: disabledKeys,\n    selectionManager: selectionManager\n  };\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $a0d645289fe9b86b$export$e7f05e985daf4b5f(props) {\n  var _props_defaultSelectedKey;\n  let [selectedKey, setSelectedKey] = (0, $58Phs$useControlledState)(props.selectedKey, (_props_defaultSelectedKey = props.defaultSelectedKey) !== null && _props_defaultSelectedKey !== void 0 ? _props_defaultSelectedKey : null, props.onSelectionChange);\n  let selectedKeys = (0, $58Phs$useMemo)(() => selectedKey != null ? [selectedKey] : [], [selectedKey]);\n  let {\n    collection: collection,\n    disabledKeys: disabledKeys,\n    selectionManager: selectionManager\n  } = (0, $e72dd72e1c76a225$export$2f645645f7bca764)({\n    ...props,\n    selectionMode: \"single\",\n    disallowEmptySelection: true,\n    allowDuplicateSelectionEvents: true,\n    selectedKeys: selectedKeys,\n    onSelectionChange: keys => {\n      var _keys_values_next_value;\n      let key = (_keys_values_next_value = keys.values().next().value) !== null && _keys_values_next_value !== void 0 ? _keys_values_next_value : null;\n      // Always fire onSelectionChange, even if the key is the same\n      // as the current key (useControlledState does not).\n      if (key === selectedKey && props.onSelectionChange) props.onSelectionChange(key);\n      setSelectedKey(key);\n    }\n  });\n  let selectedItem = selectedKey != null ? collection.getItem(selectedKey) : null;\n  return {\n    collection: collection,\n    disabledKeys: disabledKeys,\n    selectionManager: selectionManager,\n    selectedKey: selectedKey,\n    setSelectedKey: setSelectedKey,\n    selectedItem: selectedItem\n  };\n}\nexport { $e72dd72e1c76a225$export$2f645645f7bca764 as useListState, $a0d645289fe9b86b$export$e7f05e985daf4b5f as useSingleSelectListState, $a02d57049d202695$export$d085fb9e920b5ca7 as ListCollection };","map":{"version":3,"names":["$a02d57049d202695$export$d085fb9e920b5ca7","Symbol","iterator","iterable","size","keyMap","getKeys","keys","getKeyBefore","key","node","get","prevKey","getKeyAfter","nextKey","getFirstKey","firstKey","getLastKey","lastKey","getItem","at","idx","getChildren","childNodes","constructor","nodes","Map","visit","set","type","child","last","index","undefined","$e72dd72e1c76a225$export$2f645645f7bca764","props","filter","selectionState","$58Phs$useMultipleSelectionState","disabledKeys","$58Phs$useMemo","Set","factory","$58Phs$useCallback","context","suppressTextValueWarning","collection","$58Phs$useCollection","selectionManager","$58Phs$SelectionManager","cachedCollection","$58Phs$useRef","$58Phs$useEffect","focusedKey","startItem","current","cachedItemNodes","map","itemNode","itemNodes","diff","length","Math","min","max","newNode","isDisabled","setFocusedKey","$a0d645289fe9b86b$export$e7f05e985daf4b5f","_props_defaultSelectedKey","selectedKey","setSelectedKey","$58Phs$useControlledState","defaultSelectedKey","onSelectionChange","selectedKeys","selectionMode","disallowEmptySelection","allowDuplicateSelectionEvents","_keys_values_next_value","values","next","value","selectedItem"],"sources":["C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\list\\dist\\packages\\@react-stately\\list\\src\\index.ts","C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\list\\dist\\packages\\@react-stately\\list\\src\\useListState.ts","C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\list\\dist\\packages\\@react-stately\\list\\src\\ListCollection.ts","C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\list\\dist\\packages\\@react-stately\\list\\src\\useSingleSelectListState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport type {ListProps, ListState} from './useListState';\nexport type {SingleSelectListProps, SingleSelectListState} from './useSingleSelectListState';\nexport {useListState} from './useListState';\nexport {useSingleSelectListState} from './useSingleSelectListState';\nexport {ListCollection} from './ListCollection';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, CollectionStateBase, Key, Node} from '@react-types/shared';\nimport {ListCollection} from './ListCollection';\nimport {MultipleSelectionStateProps, SelectionManager, useMultipleSelectionState} from '@react-stately/selection';\nimport {useCallback, useEffect, useMemo, useRef} from 'react';\nimport {useCollection} from '@react-stately/collections';\n\nexport interface ListProps<T> extends CollectionStateBase<T>, MultipleSelectionStateProps {\n  /** Filter function to generate a filtered list of nodes. */\n  filter?: (nodes: Iterable<Node<T>>) => Iterable<Node<T>>,\n  /** @private */\n  suppressTextValueWarning?: boolean\n}\n\nexport interface ListState<T> {\n  /** A collection of items in the list. */\n  collection: Collection<Node<T>>,\n\n  /** A set of items that are disabled. */\n  disabledKeys: Set<Key>,\n\n  /** A selection manager to read and update multiple selection state. */\n  selectionManager: SelectionManager\n}\n\n/**\n * Provides state management for list-like components. Handles building a collection\n * of items from props, and manages multiple selection state.\n */\nexport function useListState<T extends object>(props: ListProps<T>): ListState<T>  {\n  let {filter} = props;\n\n  let selectionState = useMultipleSelectionState(props);\n  let disabledKeys = useMemo(() =>\n    props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n  , [props.disabledKeys]);\n\n  let factory = useCallback(nodes => filter ? new ListCollection(filter(nodes)) : new ListCollection(nodes as Iterable<Node<T>>), [filter]);\n  let context = useMemo(() => ({suppressTextValueWarning: props.suppressTextValueWarning}), [props.suppressTextValueWarning]);\n\n  let collection = useCollection(props, factory, context);\n\n  let selectionManager = useMemo(() =>\n    new SelectionManager(collection, selectionState)\n    , [collection, selectionState]\n  );\n\n  // Reset focused key if that item is deleted from the collection.\n  const cachedCollection = useRef(null);\n  useEffect(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      const startItem = cachedCollection.current.getItem(selectionState.focusedKey);\n      const cachedItemNodes = [...cachedCollection.current.getKeys()].map(\n        key => {\n          const itemNode = cachedCollection.current.getItem(key);\n          return itemNode.type === 'item' ? itemNode : null;\n        }\n      ).filter(node => node !== null);\n      const itemNodes = [...collection.getKeys()].map(\n        key => {\n          const itemNode = collection.getItem(key);\n          return itemNode.type === 'item' ? itemNode : null;\n        }\n      ).filter(node => node !== null);\n      const diff = cachedItemNodes.length - itemNodes.length;\n      let index = Math.min(\n        (\n          diff > 1 ?\n          Math.max(startItem.index - diff + 1, 0) :\n          startItem.index\n        ),\n        itemNodes.length - 1);\n      let newNode:Node<T>;\n      while (index >= 0) {\n        if (!selectionManager.isDisabled(itemNodes[index].key)) {\n          newNode = itemNodes[index];\n          break;\n        }\n        // Find next, not disabled item.\n        if (index < itemNodes.length - 1) {\n          index++;\n        // Otherwise, find previous, not disabled item.\n        } else {\n          if (index > startItem.index) {\n            index = startItem.index;\n          }\n          index--;\n        }\n      }\n      selectionState.setFocusedKey(newNode ? newNode.key : null);\n    }\n    cachedCollection.current = collection;\n  }, [collection, selectionManager, selectionState, selectionState.focusedKey]);\n\n  return {\n    collection,\n    disabledKeys,\n    selectionManager\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, Key, Node} from '@react-types/shared';\n\nexport class ListCollection<T> implements Collection<Node<T>> {\n  private keyMap: Map<Key, Node<T>> = new Map();\n  private iterable: Iterable<Node<T>>;\n  private firstKey: Key;\n  private lastKey: Key;\n\n  constructor(nodes: Iterable<Node<T>>) {\n    this.iterable = nodes;\n\n    let visit = (node: Node<T>) => {\n      this.keyMap.set(node.key, node);\n\n      if (node.childNodes && node.type === 'section') {\n        for (let child of node.childNodes) {\n          visit(child);\n        }\n      }\n    };\n\n    for (let node of nodes) {\n      visit(node);\n    }\n\n    let last: Node<T>;\n    let index = 0;\n    for (let [key, node] of this.keyMap) {\n      if (last) {\n        last.nextKey = key;\n        node.prevKey = last.key;\n      } else {\n        this.firstKey = key;\n        node.prevKey = undefined;\n      }\n\n      if (node.type === 'item') {\n        node.index = index++;\n      }\n\n      last = node;\n\n      // Set nextKey as undefined since this might be the last node\n      // If it isn't the last node, last.nextKey will properly set at start of new loop\n      last.nextKey = undefined;\n    }\n\n    this.lastKey = last?.key;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.iterable;\n  }\n\n  get size() {\n    return this.keyMap.size;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return this.firstKey;\n  }\n\n  getLastKey() {\n    return this.lastKey;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n\n  getChildren(key: Key): Iterable<Node<T>> {\n    let node = this.keyMap.get(key);\n    return node?.childNodes || [];\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionStateBase, Key, Node, SingleSelection} from '@react-types/shared';\nimport {ListState, useListState} from './useListState';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo} from 'react';\n\nexport interface SingleSelectListProps<T> extends CollectionStateBase<T>, Omit<SingleSelection, 'disallowEmptySelection'> {\n  /** Filter function to generate a filtered list of nodes. */\n  filter?: (nodes: Iterable<Node<T>>) => Iterable<Node<T>>,\n  /** @private */\n  suppressTextValueWarning?: boolean\n}\n\nexport interface SingleSelectListState<T> extends ListState<T> {\n  /** The key for the currently selected item. */\n  readonly selectedKey: Key,\n\n  /** Sets the selected key. */\n  setSelectedKey(key: Key | null): void,\n\n  /** The value of the currently selected item. */\n  readonly selectedItem: Node<T>\n}\n\n/**\n * Provides state management for list-like components with single selection.\n * Handles building a collection of items from props, and manages selection state.\n */\nexport function useSingleSelectListState<T extends object>(props: SingleSelectListProps<T>): SingleSelectListState<T>  {\n  let [selectedKey, setSelectedKey] = useControlledState(props.selectedKey, props.defaultSelectedKey ?? null, props.onSelectionChange);\n  let selectedKeys = useMemo(() => selectedKey != null ? [selectedKey] : [], [selectedKey]);\n  let {collection, disabledKeys, selectionManager} = useListState({\n    ...props,\n    selectionMode: 'single',\n    disallowEmptySelection: true,\n    allowDuplicateSelectionEvents: true,\n    selectedKeys,\n    onSelectionChange: (keys: Set<Key>) => {\n      let key = keys.values().next().value ?? null;\n\n      // Always fire onSelectionChange, even if the key is the same\n      // as the current key (useControlledState does not).\n      if (key === selectedKey && props.onSelectionChange) {\n        props.onSelectionChange(key);\n      }\n\n      setSelectedKey(key);\n    }\n  });\n\n  let selectedItem = selectedKey != null\n    ? collection.getItem(selectedKey)\n    : null;\n\n  return {\n    collection,\n    disabledKeys,\n    selectionManager,\n    selectedKey,\n    setSelectedKey,\n    selectedItem\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}