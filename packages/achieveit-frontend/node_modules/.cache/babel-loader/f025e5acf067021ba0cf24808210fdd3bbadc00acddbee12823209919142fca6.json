{"ast":null,"code":"import { useControlledState as $Qsto2$useControlledState } from \"@react-stately/utils\";\nimport { useRef as $Qsto2$useRef, useState as $Qsto2$useState, useMemo as $Qsto2$useMemo, useEffect as $Qsto2$useEffect } from \"react\";\nimport { compareNodeOrder as $Qsto2$compareNodeOrder, getFirstItem as $Qsto2$getFirstItem, getChildNodes as $Qsto2$getChildNodes } from \"@react-stately/collections\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n    * Copyright 2020 Adobe. All rights reserved.\n    * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License. You may obtain a copy\n    * of the License at http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software distributed under\n    * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n    * OF ANY KIND, either express or implied. See the License for the specific language\n    * governing permissions and limitations under the License.\n    */ /*\n       * Copyright 2020 Adobe. All rights reserved.\n       * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n       * you may not use this file except in compliance with the License. You may obtain a copy\n       * of the License at http://www.apache.org/licenses/LICENSE-2.0\n       *\n       * Unless required by applicable law or agreed to in writing, software distributed under\n       * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n       * OF ANY KIND, either express or implied. See the License for the specific language\n       * governing permissions and limitations under the License.\n       */\nclass $e40ea825a81a3709$export$52baac22726c72bf extends Set {\n  constructor(keys, anchorKey, currentKey) {\n    super(keys);\n    if (keys instanceof $e40ea825a81a3709$export$52baac22726c72bf) {\n      this.anchorKey = anchorKey || keys.anchorKey;\n      this.currentKey = currentKey || keys.currentKey;\n    } else {\n      this.anchorKey = anchorKey;\n      this.currentKey = currentKey;\n    }\n  }\n}\nfunction $7af3f5b51489e0b5$var$equalSets(setA, setB) {\n  if (setA.size !== setB.size) return false;\n  for (let item of setA) {\n    if (!setB.has(item)) return false;\n  }\n  return true;\n}\nfunction $7af3f5b51489e0b5$export$253fe78d46329472(props) {\n  let {\n    selectionMode = \"none\",\n    disallowEmptySelection: disallowEmptySelection,\n    allowDuplicateSelectionEvents: allowDuplicateSelectionEvents,\n    selectionBehavior: selectionBehaviorProp = \"toggle\",\n    disabledBehavior = \"all\"\n  } = props;\n  // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n  // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n  let isFocusedRef = (0, $Qsto2$useRef)(false);\n  let [, setFocused] = (0, $Qsto2$useState)(false);\n  let focusedKeyRef = (0, $Qsto2$useRef)(null);\n  let childFocusStrategyRef = (0, $Qsto2$useRef)(null);\n  let [, setFocusedKey] = (0, $Qsto2$useState)(null);\n  let selectedKeysProp = (0, $Qsto2$useMemo)(() => $7af3f5b51489e0b5$var$convertSelection(props.selectedKeys), [props.selectedKeys]);\n  let defaultSelectedKeys = (0, $Qsto2$useMemo)(() => $7af3f5b51489e0b5$var$convertSelection(props.defaultSelectedKeys, new (0, $e40ea825a81a3709$export$52baac22726c72bf)()), [props.defaultSelectedKeys]);\n  let [selectedKeys, setSelectedKeys] = (0, $Qsto2$useControlledState)(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);\n  let disabledKeysProp = (0, $Qsto2$useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);\n  let [selectionBehavior, setSelectionBehavior] = (0, $Qsto2$useState)(selectionBehaviorProp);\n  // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n  // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n  if (selectionBehaviorProp === \"replace\" && selectionBehavior === \"toggle\" && typeof selectedKeys === \"object\" && selectedKeys.size === 0) setSelectionBehavior(\"replace\");\n  // If the selectionBehavior prop changes, update the state as well.\n  let lastSelectionBehavior = (0, $Qsto2$useRef)(selectionBehaviorProp);\n  (0, $Qsto2$useEffect)(() => {\n    if (selectionBehaviorProp !== lastSelectionBehavior.current) {\n      setSelectionBehavior(selectionBehaviorProp);\n      lastSelectionBehavior.current = selectionBehaviorProp;\n    }\n  }, [selectionBehaviorProp]);\n  return {\n    selectionMode: selectionMode,\n    disallowEmptySelection: disallowEmptySelection,\n    selectionBehavior: selectionBehavior,\n    setSelectionBehavior: setSelectionBehavior,\n    get isFocused() {\n      return isFocusedRef.current;\n    },\n    setFocused(f) {\n      isFocusedRef.current = f;\n      setFocused(f);\n    },\n    get focusedKey() {\n      return focusedKeyRef.current;\n    },\n    get childFocusStrategy() {\n      return childFocusStrategyRef.current;\n    },\n    setFocusedKey(k, childFocusStrategy = \"first\") {\n      focusedKeyRef.current = k;\n      childFocusStrategyRef.current = childFocusStrategy;\n      setFocusedKey(k);\n    },\n    selectedKeys: selectedKeys,\n    setSelectedKeys(keys) {\n      if (allowDuplicateSelectionEvents || !$7af3f5b51489e0b5$var$equalSets(keys, selectedKeys)) setSelectedKeys(keys);\n    },\n    disabledKeys: disabledKeysProp,\n    disabledBehavior: disabledBehavior\n  };\n}\nfunction $7af3f5b51489e0b5$var$convertSelection(selection, defaultValue) {\n  if (!selection) return defaultValue;\n  return selection === \"all\" ? \"all\" : new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selection);\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nclass $d496c0a20b6e58ec$export$6c8a5aaad13c9852 {\n  /**\n  * The type of selection that is allowed in the collection.\n  */\n  get selectionMode() {\n    return this.state.selectionMode;\n  }\n  /**\n  * Whether the collection allows empty selection.\n  */\n  get disallowEmptySelection() {\n    return this.state.disallowEmptySelection;\n  }\n  /**\n  * The selection behavior for the collection.\n  */\n  get selectionBehavior() {\n    return this.state.selectionBehavior;\n  }\n  /**\n  * Sets the selection behavior for the collection.\n  */\n  setSelectionBehavior(selectionBehavior) {\n    this.state.setSelectionBehavior(selectionBehavior);\n  }\n  /**\n  * Whether the collection is currently focused.\n  */\n  get isFocused() {\n    return this.state.isFocused;\n  }\n  /**\n  * Sets whether the collection is focused.\n  */\n  setFocused(isFocused) {\n    this.state.setFocused(isFocused);\n  }\n  /**\n  * The current focused key in the collection.\n  */\n  get focusedKey() {\n    return this.state.focusedKey;\n  }\n  /** Whether the first or last child of the focused key should receive focus. */\n  get childFocusStrategy() {\n    return this.state.childFocusStrategy;\n  }\n  /**\n  * Sets the focused key.\n  */\n  setFocusedKey(key, childFocusStrategy) {\n    if (key == null || this.collection.getItem(key)) this.state.setFocusedKey(key, childFocusStrategy);\n  }\n  /**\n  * The currently selected keys in the collection.\n  */\n  get selectedKeys() {\n    return this.state.selectedKeys === \"all\" ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;\n  }\n  /**\n  * The raw selection value for the collection.\n  * Either 'all' for select all, or a set of keys.\n  */\n  get rawSelection() {\n    return this.state.selectedKeys;\n  }\n  /**\n  * Returns whether a key is selected.\n  */\n  isSelected(key) {\n    if (this.state.selectionMode === \"none\") return false;\n    key = this.getKey(key);\n    return this.state.selectedKeys === \"all\" ? this.canSelectItem(key) : this.state.selectedKeys.has(key);\n  }\n  /**\n  * Whether the selection is empty.\n  */\n  get isEmpty() {\n    return this.state.selectedKeys !== \"all\" && this.state.selectedKeys.size === 0;\n  }\n  /**\n  * Whether all items in the collection are selected.\n  */\n  get isSelectAll() {\n    if (this.isEmpty) return false;\n    if (this.state.selectedKeys === \"all\") return true;\n    if (this._isSelectAll != null) return this._isSelectAll;\n    let allKeys = this.getSelectAllKeys();\n    let selectedKeys = this.state.selectedKeys;\n    this._isSelectAll = allKeys.every(k => selectedKeys.has(k));\n    return this._isSelectAll;\n  }\n  get firstSelectedKey() {\n    let first = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!first || item && (0, $Qsto2$compareNodeOrder)(this.collection, item, first) < 0) first = item;\n    }\n    return first === null || first === void 0 ? void 0 : first.key;\n  }\n  get lastSelectedKey() {\n    let last = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!last || item && (0, $Qsto2$compareNodeOrder)(this.collection, item, last) > 0) last = item;\n    }\n    return last === null || last === void 0 ? void 0 : last.key;\n  }\n  get disabledKeys() {\n    return this.state.disabledKeys;\n  }\n  get disabledBehavior() {\n    return this.state.disabledBehavior;\n  }\n  /**\n  * Extends the selection to the given key.\n  */\n  extendSelection(toKey) {\n    if (this.selectionMode === \"none\") return;\n    if (this.selectionMode === \"single\") {\n      this.replaceSelection(toKey);\n      return;\n    }\n    toKey = this.getKey(toKey);\n    let selection;\n    // Only select the one key if coming from a select all.\n    if (this.state.selectedKeys === \"all\") selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)([toKey], toKey, toKey);else {\n      let selectedKeys = this.state.selectedKeys;\n      let anchorKey = selectedKeys.anchorKey || toKey;\n      selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selectedKeys, anchorKey, toKey);\n      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey)) selection.delete(key);\n      for (let key of this.getKeyRange(toKey, anchorKey)) if (this.canSelectItem(key)) selection.add(key);\n    }\n    this.state.setSelectedKeys(selection);\n  }\n  getKeyRange(from, to) {\n    let fromItem = this.collection.getItem(from);\n    let toItem = this.collection.getItem(to);\n    if (fromItem && toItem) {\n      if ((0, $Qsto2$compareNodeOrder)(this.collection, fromItem, toItem) <= 0) return this.getKeyRangeInternal(from, to);\n      return this.getKeyRangeInternal(to, from);\n    }\n    return [];\n  }\n  getKeyRangeInternal(from, to) {\n    let keys = [];\n    let key = from;\n    while (key) {\n      let item = this.collection.getItem(key);\n      if (item && item.type === \"item\" || item.type === \"cell\" && this.allowsCellSelection) keys.push(key);\n      if (key === to) return keys;\n      key = this.collection.getKeyAfter(key);\n    }\n    return [];\n  }\n  getKey(key) {\n    let item = this.collection.getItem(key);\n    if (!item)\n      // ¯\\_(ツ)_/¯\n      return key;\n    // If cell selection is allowed, just return the key.\n    if (item.type === \"cell\" && this.allowsCellSelection) return key;\n    // Find a parent item to select\n    while (item.type !== \"item\" && item.parentKey != null) item = this.collection.getItem(item.parentKey);\n    if (!item || item.type !== \"item\") return null;\n    return item.key;\n  }\n  /**\n  * Toggles whether the given key is selected.\n  */\n  toggleSelection(key) {\n    if (this.selectionMode === \"none\") return;\n    if (this.selectionMode === \"single\" && !this.isSelected(key)) {\n      this.replaceSelection(key);\n      return;\n    }\n    key = this.getKey(key);\n    if (key == null) return;\n    let keys = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(this.state.selectedKeys === \"all\" ? this.getSelectAllKeys() : this.state.selectedKeys);\n    if (keys.has(key)) keys.delete(key);else if (this.canSelectItem(key)) {\n      keys.add(key);\n      keys.anchorKey = key;\n      keys.currentKey = key;\n    }\n    if (this.disallowEmptySelection && keys.size === 0) return;\n    this.state.setSelectedKeys(keys);\n  }\n  /**\n  * Replaces the selection with only the given key.\n  */\n  replaceSelection(key) {\n    if (this.selectionMode === \"none\") return;\n    key = this.getKey(key);\n    if (key == null) return;\n    let selection = this.canSelectItem(key) ? new (0, $e40ea825a81a3709$export$52baac22726c72bf)([key], key, key) : new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n    this.state.setSelectedKeys(selection);\n  }\n  /**\n  * Replaces the selection with the given keys.\n  */\n  setSelectedKeys(keys) {\n    if (this.selectionMode === \"none\") return;\n    let selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n    for (let key of keys) {\n      key = this.getKey(key);\n      if (key != null) {\n        selection.add(key);\n        if (this.selectionMode === \"single\") break;\n      }\n    }\n    this.state.setSelectedKeys(selection);\n  }\n  getSelectAllKeys() {\n    let keys = [];\n    let addKeys = key => {\n      while (key) {\n        if (this.canSelectItem(key)) {\n          let item = this.collection.getItem(key);\n          if (item.type === \"item\") keys.push(key);\n          // Add child keys. If cell selection is allowed, then include item children too.\n          if (item.hasChildNodes && (this.allowsCellSelection || item.type !== \"item\")) addKeys((0, $Qsto2$getFirstItem)((0, $Qsto2$getChildNodes)(item, this.collection)).key);\n        }\n        key = this.collection.getKeyAfter(key);\n      }\n    };\n    addKeys(this.collection.getFirstKey());\n    return keys;\n  }\n  /**\n  * Selects all items in the collection.\n  */\n  selectAll() {\n    if (!this.isSelectAll && this.selectionMode === \"multiple\") this.state.setSelectedKeys(\"all\");\n  }\n  /**\n  * Removes all keys from the selection.\n  */\n  clearSelection() {\n    if (!this.disallowEmptySelection && (this.state.selectedKeys === \"all\" || this.state.selectedKeys.size > 0)) this.state.setSelectedKeys(new (0, $e40ea825a81a3709$export$52baac22726c72bf)());\n  }\n  /**\n  * Toggles between select all and an empty selection.\n  */\n  toggleSelectAll() {\n    if (this.isSelectAll) this.clearSelection();else this.selectAll();\n  }\n  select(key, e) {\n    if (this.selectionMode === \"none\") return;\n    if (this.selectionMode === \"single\") {\n      if (this.isSelected(key) && !this.disallowEmptySelection) this.toggleSelection(key);else this.replaceSelection(key);\n    } else if (this.selectionBehavior === \"toggle\" || e && (e.pointerType === \"touch\" || e.pointerType === \"virtual\"))\n      // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n      this.toggleSelection(key);else this.replaceSelection(key);\n  }\n  /**\n  * Returns whether the current selection is equal to the given selection.\n  */\n  isSelectionEqual(selection) {\n    if (selection === this.state.selectedKeys) return true;\n    // Check if the set of keys match.\n    let selectedKeys = this.selectedKeys;\n    if (selection.size !== selectedKeys.size) return false;\n    for (let key of selection) {\n      if (!selectedKeys.has(key)) return false;\n    }\n    for (let key of selectedKeys) {\n      if (!selection.has(key)) return false;\n    }\n    return true;\n  }\n  canSelectItem(key) {\n    if (this.state.selectionMode === \"none\" || this.state.disabledKeys.has(key)) return false;\n    let item = this.collection.getItem(key);\n    if (!item || item.type === \"cell\" && !this.allowsCellSelection) return false;\n    return true;\n  }\n  isDisabled(key) {\n    return this.state.disabledKeys.has(key) && this.state.disabledBehavior === \"all\";\n  }\n  isLink(key) {\n    var _this_collection_getItem_props, _this_collection_getItem;\n    return !!((_this_collection_getItem = this.collection.getItem(key)) === null || _this_collection_getItem === void 0 ? void 0 : (_this_collection_getItem_props = _this_collection_getItem.props) === null || _this_collection_getItem_props === void 0 ? void 0 : _this_collection_getItem_props.href);\n  }\n  constructor(collection, state, options) {\n    this.collection = collection;\n    this.state = state;\n    var _options_allowsCellSelection;\n    this.allowsCellSelection = (_options_allowsCellSelection = options === null || options === void 0 ? void 0 : options.allowsCellSelection) !== null && _options_allowsCellSelection !== void 0 ? _options_allowsCellSelection : false;\n    this._isSelectAll = null;\n  }\n}\nexport { $7af3f5b51489e0b5$export$253fe78d46329472 as useMultipleSelectionState, $d496c0a20b6e58ec$export$6c8a5aaad13c9852 as SelectionManager };","map":{"version":3,"names":["$e40ea825a81a3709$export$52baac22726c72bf","Set","constructor","keys","anchorKey","currentKey","$7af3f5b51489e0b5$var$equalSets","setA","setB","size","item","has","$7af3f5b51489e0b5$export$253fe78d46329472","props","selectionMode","disallowEmptySelection","allowDuplicateSelectionEvents","selectionBehavior","selectionBehaviorProp","disabledBehavior","isFocusedRef","$Qsto2$useRef","setFocused","$Qsto2$useState","focusedKeyRef","childFocusStrategyRef","setFocusedKey","selectedKeysProp","$Qsto2$useMemo","$7af3f5b51489e0b5$var$convertSelection","selectedKeys","defaultSelectedKeys","setSelectedKeys","$Qsto2$useControlledState","onSelectionChange","disabledKeysProp","disabledKeys","setSelectionBehavior","lastSelectionBehavior","$Qsto2$useEffect","current","isFocused","f","focusedKey","childFocusStrategy","k","selection","defaultValue","$d496c0a20b6e58ec$export$6c8a5aaad13c9852","state","key","collection","getItem","getSelectAllKeys","rawSelection","isSelected","getKey","canSelectItem","isEmpty","isSelectAll","_isSelectAll","allKeys","every","firstSelectedKey","first","$Qsto2$compareNodeOrder","lastSelectedKey","last","extendSelection","toKey","replaceSelection","getKeyRange","delete","add","from","to","fromItem","toItem","getKeyRangeInternal","type","allowsCellSelection","push","getKeyAfter","parentKey","toggleSelection","addKeys","hasChildNodes","$Qsto2$getFirstItem","$Qsto2$getChildNodes","getFirstKey","selectAll","clearSelection","toggleSelectAll","select","e","pointerType","isSelectionEqual","isDisabled","isLink","_this_collection_getItem_props","_this_collection_getItem","href","options","_options_allowsCellSelection"],"sources":["C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\selection\\dist\\packages\\@react-stately\\selection\\src\\index.ts","C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\selection\\dist\\packages\\@react-stately\\selection\\src\\useMultipleSelectionState.ts","C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\selection\\dist\\packages\\@react-stately\\selection\\src\\Selection.ts","C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\selection\\dist\\packages\\@react-stately\\selection\\src\\SelectionManager.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport type {MultipleSelectionStateProps} from './useMultipleSelectionState';\nexport type {FocusState, SingleSelectionState, MultipleSelectionState, MultipleSelectionManager} from './types';\nexport {useMultipleSelectionState} from './useMultipleSelectionState';\nexport {SelectionManager} from './SelectionManager';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DisabledBehavior, Key, MultipleSelection, SelectionBehavior, SelectionMode} from '@react-types/shared';\nimport {MultipleSelectionState} from './types';\nimport {Selection} from './Selection';\nimport {useControlledState} from '@react-stately/utils';\nimport {useEffect, useMemo, useRef, useState} from 'react';\n\nfunction equalSets(setA, setB) {\n  if (setA.size !== setB.size) {\n    return false;\n  }\n\n  for (let item of setA) {\n    if (!setB.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport interface MultipleSelectionStateProps extends MultipleSelection {\n  /** How multiple selection should behave in the collection. */\n  selectionBehavior?: SelectionBehavior,\n  /** Whether onSelectionChange should fire even if the new set of keys is the same as the last. */\n  allowDuplicateSelectionEvents?: boolean,\n  /** Whether `disabledKeys` applies to all interactions, or only selection. */\n  disabledBehavior?: DisabledBehavior\n}\n\n/**\n * Manages state for multiple selection and focus in a collection.\n */\nexport function useMultipleSelectionState(props: MultipleSelectionStateProps): MultipleSelectionState {\n  let {\n    selectionMode = 'none' as SelectionMode,\n    disallowEmptySelection,\n    allowDuplicateSelectionEvents,\n    selectionBehavior: selectionBehaviorProp = 'toggle',\n    disabledBehavior = 'all'\n  } = props;\n\n  // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n  // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n  let isFocusedRef = useRef(false);\n  let [, setFocused] = useState(false);\n  let focusedKeyRef = useRef(null);\n  let childFocusStrategyRef = useRef(null);\n  let [, setFocusedKey] = useState(null);\n  let selectedKeysProp = useMemo(() => convertSelection(props.selectedKeys), [props.selectedKeys]);\n  let defaultSelectedKeys = useMemo(() => convertSelection(props.defaultSelectedKeys, new Selection()), [props.defaultSelectedKeys]);\n  let [selectedKeys, setSelectedKeys] = useControlledState(\n    selectedKeysProp,\n    defaultSelectedKeys,\n    props.onSelectionChange\n  );\n  let disabledKeysProp = useMemo(() =>\n    props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n  , [props.disabledKeys]);\n  let [selectionBehavior, setSelectionBehavior] = useState(selectionBehaviorProp);\n\n  // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n  // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n  if (selectionBehaviorProp === 'replace' && selectionBehavior === 'toggle' && typeof selectedKeys === 'object' && selectedKeys.size === 0) {\n    setSelectionBehavior('replace');\n  }\n\n  // If the selectionBehavior prop changes, update the state as well.\n  let lastSelectionBehavior = useRef(selectionBehaviorProp);\n  useEffect(() => {\n    if (selectionBehaviorProp !== lastSelectionBehavior.current) {\n      setSelectionBehavior(selectionBehaviorProp);\n      lastSelectionBehavior.current = selectionBehaviorProp;\n    }\n  }, [selectionBehaviorProp]);\n\n  return {\n    selectionMode,\n    disallowEmptySelection,\n    selectionBehavior,\n    setSelectionBehavior,\n    get isFocused() {\n      return isFocusedRef.current;\n    },\n    setFocused(f) {\n      isFocusedRef.current = f;\n      setFocused(f);\n    },\n    get focusedKey() {\n      return focusedKeyRef.current;\n    },\n    get childFocusStrategy() {\n      return childFocusStrategyRef.current;\n    },\n    setFocusedKey(k, childFocusStrategy = 'first') {\n      focusedKeyRef.current = k;\n      childFocusStrategyRef.current = childFocusStrategy;\n      setFocusedKey(k);\n    },\n    selectedKeys,\n    setSelectedKeys(keys) {\n      if (allowDuplicateSelectionEvents || !equalSets(keys, selectedKeys)) {\n        setSelectedKeys(keys);\n      }\n    },\n    disabledKeys: disabledKeysProp,\n    disabledBehavior\n  };\n}\n\nfunction convertSelection(selection: 'all' | Iterable<Key>, defaultValue?: Selection): 'all' | Set<Key> {\n  if (!selection) {\n    return defaultValue;\n  }\n\n  return selection === 'all'\n    ? 'all'\n    : new Selection(selection);\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from '@react-types/shared';\n\n/**\n * A Selection is a special Set containing Keys, which also has an anchor\n * and current selected key for use when range selecting.\n */\nexport class Selection extends Set<Key> {\n  anchorKey: Key;\n  currentKey: Key;\n\n  constructor(keys?: Iterable<Key> | Selection, anchorKey?: Key, currentKey?: Key) {\n    super(keys);\n    if (keys instanceof Selection) {\n      this.anchorKey = anchorKey || keys.anchorKey;\n      this.currentKey = currentKey || keys.currentKey;\n    } else {\n      this.anchorKey = anchorKey;\n      this.currentKey = currentKey;\n    }\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  Collection, DisabledBehavior,\n  FocusStrategy,\n  Selection as ISelection,\n  Key,\n  LongPressEvent,\n  Node,\n  PressEvent,\n  SelectionBehavior,\n  SelectionMode\n} from '@react-types/shared';\nimport {compareNodeOrder, getChildNodes, getFirstItem} from '@react-stately/collections';\nimport {MultipleSelectionManager, MultipleSelectionState} from './types';\nimport {Selection} from './Selection';\n\ninterface SelectionManagerOptions {\n  allowsCellSelection?: boolean\n}\n\n/**\n * An interface for reading and updating multiple selection state.\n */\nexport class SelectionManager implements MultipleSelectionManager {\n  private collection: Collection<Node<unknown>>;\n  private state: MultipleSelectionState;\n  private allowsCellSelection: boolean;\n  private _isSelectAll: boolean;\n\n  constructor(collection: Collection<Node<unknown>>, state: MultipleSelectionState, options?: SelectionManagerOptions) {\n    this.collection = collection;\n    this.state = state;\n    this.allowsCellSelection = options?.allowsCellSelection ?? false;\n    this._isSelectAll = null;\n  }\n\n  /**\n   * The type of selection that is allowed in the collection.\n   */\n  get selectionMode(): SelectionMode {\n    return this.state.selectionMode;\n  }\n\n  /**\n   * Whether the collection allows empty selection.\n   */\n  get disallowEmptySelection(): boolean {\n    return this.state.disallowEmptySelection;\n  }\n\n  /**\n   * The selection behavior for the collection.\n   */\n  get selectionBehavior(): SelectionBehavior {\n    return this.state.selectionBehavior;\n  }\n\n  /**\n   * Sets the selection behavior for the collection.\n   */\n  setSelectionBehavior(selectionBehavior: SelectionBehavior) {\n    this.state.setSelectionBehavior(selectionBehavior);\n  }\n\n  /**\n   * Whether the collection is currently focused.\n   */\n  get isFocused(): boolean {\n    return this.state.isFocused;\n  }\n\n  /**\n   * Sets whether the collection is focused.\n   */\n  setFocused(isFocused: boolean) {\n    this.state.setFocused(isFocused);\n  }\n\n  /**\n   * The current focused key in the collection.\n   */\n  get focusedKey(): Key {\n    return this.state.focusedKey;\n  }\n\n  /** Whether the first or last child of the focused key should receive focus. */\n  get childFocusStrategy(): FocusStrategy {\n    return this.state.childFocusStrategy;\n  }\n\n  /**\n   * Sets the focused key.\n   */\n  setFocusedKey(key: Key | null, childFocusStrategy?: FocusStrategy) {\n    if (key == null || this.collection.getItem(key)) {\n      this.state.setFocusedKey(key, childFocusStrategy);\n    }\n  }\n\n  /**\n   * The currently selected keys in the collection.\n   */\n  get selectedKeys(): Set<Key> {\n    return this.state.selectedKeys === 'all'\n      ? new Set(this.getSelectAllKeys())\n      : this.state.selectedKeys;\n  }\n\n  /**\n   * The raw selection value for the collection.\n   * Either 'all' for select all, or a set of keys.\n   */\n  get rawSelection(): ISelection {\n    return this.state.selectedKeys;\n  }\n\n  /**\n   * Returns whether a key is selected.\n   */\n  isSelected(key: Key) {\n    if (this.state.selectionMode === 'none') {\n      return false;\n    }\n\n    key = this.getKey(key);\n    return this.state.selectedKeys === 'all'\n      ? this.canSelectItem(key)\n      : this.state.selectedKeys.has(key);\n  }\n\n  /**\n   * Whether the selection is empty.\n   */\n  get isEmpty(): boolean {\n    return this.state.selectedKeys !== 'all' && this.state.selectedKeys.size === 0;\n  }\n\n  /**\n   * Whether all items in the collection are selected.\n   */\n  get isSelectAll(): boolean {\n    if (this.isEmpty) {\n      return false;\n    }\n\n    if (this.state.selectedKeys === 'all') {\n      return true;\n    }\n\n    if (this._isSelectAll != null) {\n      return this._isSelectAll;\n    }\n\n    let allKeys = this.getSelectAllKeys();\n    let selectedKeys = this.state.selectedKeys;\n    this._isSelectAll = allKeys.every(k => selectedKeys.has(k));\n    return this._isSelectAll;\n  }\n\n  get firstSelectedKey(): Key | null {\n    let first: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!first || (item && compareNodeOrder(this.collection, item, first) < 0)) {\n        first = item;\n      }\n    }\n\n    return first?.key;\n  }\n\n  get lastSelectedKey(): Key | null {\n    let last: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!last || (item && compareNodeOrder(this.collection, item, last) > 0)) {\n        last = item;\n      }\n    }\n\n    return last?.key;\n  }\n\n  get disabledKeys(): Set<Key> {\n    return this.state.disabledKeys;\n  }\n\n  get disabledBehavior(): DisabledBehavior {\n    return this.state.disabledBehavior;\n  }\n\n  /**\n   * Extends the selection to the given key.\n   */\n  extendSelection(toKey: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      this.replaceSelection(toKey);\n      return;\n    }\n\n    toKey = this.getKey(toKey);\n\n    let selection: Selection;\n\n    // Only select the one key if coming from a select all.\n    if (this.state.selectedKeys === 'all') {\n      selection = new Selection([toKey], toKey, toKey);\n    } else {\n      let selectedKeys = this.state.selectedKeys as Selection;\n      let anchorKey = selectedKeys.anchorKey || toKey;\n      selection = new Selection(selectedKeys, anchorKey, toKey);\n      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey)) {\n        selection.delete(key);\n      }\n\n      for (let key of this.getKeyRange(toKey, anchorKey)) {\n        if (this.canSelectItem(key)) {\n          selection.add(key);\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getKeyRange(from: Key, to: Key) {\n    let fromItem = this.collection.getItem(from);\n    let toItem = this.collection.getItem(to);\n    if (fromItem && toItem) {\n      if (compareNodeOrder(this.collection, fromItem, toItem) <= 0) {\n        return this.getKeyRangeInternal(from, to);\n      }\n\n      return this.getKeyRangeInternal(to, from);\n    }\n\n    return [];\n  }\n\n  private getKeyRangeInternal(from: Key, to: Key) {\n    let keys: Key[] = [];\n    let key = from;\n    while (key) {\n      let item = this.collection.getItem(key);\n      if (item && item.type === 'item' || (item.type === 'cell' && this.allowsCellSelection)) {\n        keys.push(key);\n      }\n\n      if (key === to) {\n        return keys;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return [];\n  }\n\n  private getKey(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      // ¯\\_(ツ)_/¯\n      return key;\n    }\n\n    // If cell selection is allowed, just return the key.\n    if (item.type === 'cell' && this.allowsCellSelection) {\n      return key;\n    }\n\n    // Find a parent item to select\n    while (item.type !== 'item' && item.parentKey != null) {\n      item = this.collection.getItem(item.parentKey);\n    }\n\n    if (!item || item.type !== 'item') {\n      return null;\n    }\n\n    return item.key;\n  }\n\n  /**\n   * Toggles whether the given key is selected.\n   */\n  toggleSelection(key: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single' && !this.isSelected(key)) {\n      this.replaceSelection(key);\n      return;\n    }\n\n    key = this.getKey(key);\n    if (key == null) {\n      return;\n    }\n\n    let keys = new Selection(this.state.selectedKeys === 'all' ? this.getSelectAllKeys() : this.state.selectedKeys);\n    if (keys.has(key)) {\n      keys.delete(key);\n      // TODO: move anchor to last selected key...\n      // Does `current` need to move here too?\n    } else if (this.canSelectItem(key)) {\n      keys.add(key);\n      keys.anchorKey = key;\n      keys.currentKey = key;\n    }\n\n    if (this.disallowEmptySelection && keys.size === 0) {\n      return;\n    }\n\n    this.state.setSelectedKeys(keys);\n  }\n\n  /**\n   * Replaces the selection with only the given key.\n   */\n  replaceSelection(key: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    key = this.getKey(key);\n    if (key == null) {\n      return;\n    }\n\n    let selection = this.canSelectItem(key)\n      ? new Selection([key], key, key)\n      : new Selection();\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  /**\n   * Replaces the selection with the given keys.\n   */\n  setSelectedKeys(keys: Iterable<Key>) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    let selection = new Selection();\n    for (let key of keys) {\n      key = this.getKey(key);\n      if (key != null) {\n        selection.add(key);\n        if (this.selectionMode === 'single') {\n          break;\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getSelectAllKeys() {\n    let keys: Key[] = [];\n    let addKeys = (key: Key) => {\n      while (key) {\n        if (this.canSelectItem(key)) {\n          let item = this.collection.getItem(key);\n          if (item.type === 'item') {\n            keys.push(key);\n          }\n\n          // Add child keys. If cell selection is allowed, then include item children too.\n          if (item.hasChildNodes && (this.allowsCellSelection || item.type !== 'item')) {\n            addKeys(getFirstItem(getChildNodes(item, this.collection)).key);\n          }\n        }\n\n        key = this.collection.getKeyAfter(key);\n      }\n    };\n\n    addKeys(this.collection.getFirstKey());\n    return keys;\n  }\n\n  /**\n   * Selects all items in the collection.\n   */\n  selectAll() {\n    if (!this.isSelectAll && this.selectionMode === 'multiple') {\n      this.state.setSelectedKeys('all');\n    }\n  }\n\n  /**\n   * Removes all keys from the selection.\n   */\n  clearSelection() {\n    if (!this.disallowEmptySelection && (this.state.selectedKeys === 'all' || this.state.selectedKeys.size > 0)) {\n      this.state.setSelectedKeys(new Selection());\n    }\n  }\n\n  /**\n   * Toggles between select all and an empty selection.\n   */\n  toggleSelectAll() {\n    if (this.isSelectAll) {\n      this.clearSelection();\n    } else {\n      this.selectAll();\n    }\n  }\n\n  select(key: Key, e?: PressEvent | LongPressEvent | PointerEvent) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      if (this.isSelected(key) && !this.disallowEmptySelection) {\n        this.toggleSelection(key);\n      } else {\n        this.replaceSelection(key);\n      }\n    } else if (this.selectionBehavior === 'toggle' || (e && (e.pointerType === 'touch' || e.pointerType === 'virtual'))) {\n      // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n      this.toggleSelection(key);\n    } else {\n      this.replaceSelection(key);\n    }\n  }\n\n  /**\n   * Returns whether the current selection is equal to the given selection.\n   */\n  isSelectionEqual(selection: Set<Key>) {\n    if (selection === this.state.selectedKeys) {\n      return true;\n    }\n\n    // Check if the set of keys match.\n    let selectedKeys = this.selectedKeys;\n    if (selection.size !== selectedKeys.size) {\n      return false;\n    }\n\n    for (let key of selection) {\n      if (!selectedKeys.has(key)) {\n        return false;\n      }\n    }\n\n    for (let key of selectedKeys) {\n      if (!selection.has(key)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  canSelectItem(key: Key) {\n    if (this.state.selectionMode === 'none' || this.state.disabledKeys.has(key)) {\n      return false;\n    }\n\n    let item = this.collection.getItem(key);\n    if (!item || (item.type === 'cell' && !this.allowsCellSelection)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  isDisabled(key: Key) {\n    return this.state.disabledKeys.has(key) && this.state.disabledBehavior === 'all';\n  }\n\n  isLink(key: Key) {\n    return !!this.collection.getItem(key)?.props?.href;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}