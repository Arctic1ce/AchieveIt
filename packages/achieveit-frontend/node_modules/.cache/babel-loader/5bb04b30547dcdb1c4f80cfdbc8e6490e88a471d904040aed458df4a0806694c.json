{"ast":null,"code":"module.exports = flatten;\nflatten.flatten = flatten;\nflatten.unflatten = unflatten;\nfunction isBuffer(obj) {\n  return obj && obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);\n}\nfunction keyIdentity(key) {\n  return key;\n}\nfunction flatten(target, opts) {\n  opts = opts || {};\n  const delimiter = opts.delimiter || '.';\n  const maxDepth = opts.maxDepth;\n  const transformKey = opts.transformKey || keyIdentity;\n  const output = {};\n  function step(object, prev, currentDepth) {\n    currentDepth = currentDepth || 1;\n    Object.keys(object).forEach(function (key) {\n      const value = object[key];\n      const isarray = opts.safe && Array.isArray(value);\n      const type = Object.prototype.toString.call(value);\n      const isbuffer = isBuffer(value);\n      const isobject = type === '[object Object]' || type === '[object Array]';\n      const newKey = prev ? prev + delimiter + transformKey(key) : transformKey(key);\n      if (!isarray && !isbuffer && isobject && Object.keys(value).length && (!opts.maxDepth || currentDepth < maxDepth)) {\n        return step(value, newKey, currentDepth + 1);\n      }\n      output[newKey] = value;\n    });\n  }\n  step(target);\n  return output;\n}\nfunction unflatten(target, opts) {\n  opts = opts || {};\n  const delimiter = opts.delimiter || '.';\n  const overwrite = opts.overwrite || false;\n  const transformKey = opts.transformKey || keyIdentity;\n  const result = {};\n  const isbuffer = isBuffer(target);\n  if (isbuffer || Object.prototype.toString.call(target) !== '[object Object]') {\n    return target;\n  }\n\n  // safely ensure that the key is\n  // an integer.\n  function getkey(key) {\n    const parsedKey = Number(key);\n    return isNaN(parsedKey) || key.indexOf('.') !== -1 || opts.object ? key : parsedKey;\n  }\n  function addKeys(keyPrefix, recipient, target) {\n    return Object.keys(target).reduce(function (result, key) {\n      result[keyPrefix + delimiter + key] = target[key];\n      return result;\n    }, recipient);\n  }\n  function isEmpty(val) {\n    const type = Object.prototype.toString.call(val);\n    const isArray = type === '[object Array]';\n    const isObject = type === '[object Object]';\n    if (!val) {\n      return true;\n    } else if (isArray) {\n      return !val.length;\n    } else if (isObject) {\n      return !Object.keys(val).length;\n    }\n  }\n  target = Object.keys(target).reduce(function (result, key) {\n    const type = Object.prototype.toString.call(target[key]);\n    const isObject = type === '[object Object]' || type === '[object Array]';\n    if (!isObject || isEmpty(target[key])) {\n      result[key] = target[key];\n      return result;\n    } else {\n      return addKeys(key, result, flatten(target[key], opts));\n    }\n  }, {});\n  Object.keys(target).forEach(function (key) {\n    const split = key.split(delimiter).map(transformKey);\n    let key1 = getkey(split.shift());\n    let key2 = getkey(split[0]);\n    let recipient = result;\n    while (key2 !== undefined) {\n      if (key1 === '__proto__') {\n        return;\n      }\n      const type = Object.prototype.toString.call(recipient[key1]);\n      const isobject = type === '[object Object]' || type === '[object Array]';\n\n      // do not write over falsey, non-undefined values if overwrite is false\n      if (!overwrite && !isobject && typeof recipient[key1] !== 'undefined') {\n        return;\n      }\n      if (overwrite && !isobject || !overwrite && recipient[key1] == null) {\n        recipient[key1] = typeof key2 === 'number' && !opts.object ? [] : {};\n      }\n      recipient = recipient[key1];\n      if (split.length > 0) {\n        key1 = getkey(split.shift());\n        key2 = getkey(split[0]);\n      }\n    }\n\n    // unflatten again for 'messy objects'\n    recipient[key1] = unflatten(target[key], opts);\n  });\n  return result;\n}","map":{"version":3,"names":["module","exports","flatten","unflatten","isBuffer","obj","constructor","keyIdentity","key","target","opts","delimiter","maxDepth","transformKey","output","step","object","prev","currentDepth","Object","keys","forEach","value","isarray","safe","Array","isArray","type","prototype","toString","call","isbuffer","isobject","newKey","length","overwrite","result","getkey","parsedKey","Number","isNaN","indexOf","addKeys","keyPrefix","recipient","reduce","isEmpty","val","isObject","split","map","key1","shift","key2","undefined"],"sources":["C:/Users/joelp/csc-307-achieveit/AchieveIt/node_modules/flat/index.js"],"sourcesContent":["module.exports = flatten\nflatten.flatten = flatten\nflatten.unflatten = unflatten\n\nfunction isBuffer (obj) {\n  return obj &&\n    obj.constructor &&\n    (typeof obj.constructor.isBuffer === 'function') &&\n    obj.constructor.isBuffer(obj)\n}\n\nfunction keyIdentity (key) {\n  return key\n}\n\nfunction flatten (target, opts) {\n  opts = opts || {}\n\n  const delimiter = opts.delimiter || '.'\n  const maxDepth = opts.maxDepth\n  const transformKey = opts.transformKey || keyIdentity\n  const output = {}\n\n  function step (object, prev, currentDepth) {\n    currentDepth = currentDepth || 1\n    Object.keys(object).forEach(function (key) {\n      const value = object[key]\n      const isarray = opts.safe && Array.isArray(value)\n      const type = Object.prototype.toString.call(value)\n      const isbuffer = isBuffer(value)\n      const isobject = (\n        type === '[object Object]' ||\n        type === '[object Array]'\n      )\n\n      const newKey = prev\n        ? prev + delimiter + transformKey(key)\n        : transformKey(key)\n\n      if (!isarray && !isbuffer && isobject && Object.keys(value).length &&\n        (!opts.maxDepth || currentDepth < maxDepth)) {\n        return step(value, newKey, currentDepth + 1)\n      }\n\n      output[newKey] = value\n    })\n  }\n\n  step(target)\n\n  return output\n}\n\nfunction unflatten (target, opts) {\n  opts = opts || {}\n\n  const delimiter = opts.delimiter || '.'\n  const overwrite = opts.overwrite || false\n  const transformKey = opts.transformKey || keyIdentity\n  const result = {}\n\n  const isbuffer = isBuffer(target)\n  if (isbuffer || Object.prototype.toString.call(target) !== '[object Object]') {\n    return target\n  }\n\n  // safely ensure that the key is\n  // an integer.\n  function getkey (key) {\n    const parsedKey = Number(key)\n\n    return (\n      isNaN(parsedKey) ||\n      key.indexOf('.') !== -1 ||\n      opts.object\n    ) ? key\n      : parsedKey\n  }\n\n  function addKeys (keyPrefix, recipient, target) {\n    return Object.keys(target).reduce(function (result, key) {\n      result[keyPrefix + delimiter + key] = target[key]\n\n      return result\n    }, recipient)\n  }\n\n  function isEmpty (val) {\n    const type = Object.prototype.toString.call(val)\n    const isArray = type === '[object Array]'\n    const isObject = type === '[object Object]'\n\n    if (!val) {\n      return true\n    } else if (isArray) {\n      return !val.length\n    } else if (isObject) {\n      return !Object.keys(val).length\n    }\n  }\n\n  target = Object.keys(target).reduce(function (result, key) {\n    const type = Object.prototype.toString.call(target[key])\n    const isObject = (type === '[object Object]' || type === '[object Array]')\n    if (!isObject || isEmpty(target[key])) {\n      result[key] = target[key]\n      return result\n    } else {\n      return addKeys(\n        key,\n        result,\n        flatten(target[key], opts)\n      )\n    }\n  }, {})\n\n  Object.keys(target).forEach(function (key) {\n    const split = key.split(delimiter).map(transformKey)\n    let key1 = getkey(split.shift())\n    let key2 = getkey(split[0])\n    let recipient = result\n\n    while (key2 !== undefined) {\n      if (key1 === '__proto__') {\n        return\n      }\n\n      const type = Object.prototype.toString.call(recipient[key1])\n      const isobject = (\n        type === '[object Object]' ||\n        type === '[object Array]'\n      )\n\n      // do not write over falsey, non-undefined values if overwrite is false\n      if (!overwrite && !isobject && typeof recipient[key1] !== 'undefined') {\n        return\n      }\n\n      if ((overwrite && !isobject) || (!overwrite && recipient[key1] == null)) {\n        recipient[key1] = (\n          typeof key2 === 'number' &&\n          !opts.object ? [] : {}\n        )\n      }\n\n      recipient = recipient[key1]\n      if (split.length > 0) {\n        key1 = getkey(split.shift())\n        key2 = getkey(split[0])\n      }\n    }\n\n    // unflatten again for 'messy objects'\n    recipient[key1] = unflatten(target[key], opts)\n  })\n\n  return result\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}