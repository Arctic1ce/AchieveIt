{"ast":null,"code":"import { Section as $6555104ff085bef4$re_export$Section, useCollection as $1BfjW$useCollection, getFirstItem as $1BfjW$getFirstItem, getLastItem as $1BfjW$getLastItem, CollectionBuilder as $1BfjW$CollectionBuilder } from \"@react-stately/collections\";\nimport $1BfjW$react, { useState as $1BfjW$useState, useMemo as $1BfjW$useMemo, useCallback as $1BfjW$useCallback } from \"react\";\nimport { useGridState as $1BfjW$useGridState, GridCollection as $1BfjW$GridCollection } from \"@react-stately/grid\";\nimport { tableNestedRows as $1BfjW$tableNestedRows } from \"@react-stately/flags\";\nimport { useControlledState as $1BfjW$useControlledState } from \"@react-stately/utils\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n    * Copyright 2022 Adobe. All rights reserved.\n    * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License. You may obtain a copy\n    * of the License at http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software distributed under\n    * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n    * OF ANY KIND, either express or implied. See the License for the specific language\n    * governing permissions and limitations under the License.\n    */ /*\n       * Copyright 2022 Adobe. All rights reserved.\n       * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n       * you may not use this file except in compliance with the License. You may obtain a copy\n       * of the License at http://www.apache.org/licenses/LICENSE-2.0\n       *\n       * Unless required by applicable law or agreed to in writing, software distributed under\n       * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n       * OF ANY KIND, either express or implied. See the License for the specific language\n       * governing permissions and limitations under the License.\n       */ /*\n          * Copyright 2022 Adobe. All rights reserved.\n          * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n          * you may not use this file except in compliance with the License. You may obtain a copy\n          * of the License at http://www.apache.org/licenses/LICENSE-2.0\n          *\n          * Unless required by applicable law or agreed to in writing, software distributed under\n          * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n          * OF ANY KIND, either express or implied. See the License for the specific language\n          * governing permissions and limitations under the License.\n          */\nfunction $6818b1c4fc67028d$export$1994a077b98ee0d5(width) {\n  return width != null && (!isNaN(width) || String(width).match(/^(\\d+)(?=%$)/) !== null);\n}\nfunction $6818b1c4fc67028d$export$9078bad4c3934604(width) {\n  if (!width) return 1;\n  let match = width.match(/^(.+)(?=fr$)/);\n  // if width is the incorrect format, just default it to a 1fr\n  if (!match) {\n    console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`, \"defaulting to '1fr'\");\n    return 1;\n  }\n  return parseFloat(match[0]);\n}\nfunction $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, tableWidth) {\n  if (typeof width === \"string\") {\n    let match = width.match(/^(\\d+)(?=%$)/);\n    if (!match) throw new Error(\"Only percentages or numbers are supported for static column widths\");\n    return tableWidth * (parseFloat(match[0]) / 100);\n  }\n  return width;\n}\nfunction $6818b1c4fc67028d$export$59185c62a7544aa0(maxWidth, tableWidth) {\n  return maxWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(maxWidth, tableWidth) : Number.MAX_SAFE_INTEGER;\n}\nfunction $6818b1c4fc67028d$export$f556054ce4358701(minWidth, tableWidth) {\n  return minWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(minWidth, tableWidth) : 0;\n}\nfunction $6818b1c4fc67028d$export$55d50dc687385491(availableWidth, columns, changedColumns, getDefaultWidth, getDefaultMinWidth) {\n  let hasNonFrozenItems = false;\n  let flexItems = columns.map((column, index) => {\n    var _column_width, _ref, _ref1;\n    let width = changedColumns.get(column.key) != null ? changedColumns.get(column.key) : (_ref1 = (_ref = (_column_width = column.width) !== null && _column_width !== void 0 ? _column_width : column.defaultWidth) !== null && _ref !== void 0 ? _ref : getDefaultWidth === null || getDefaultWidth === void 0 ? void 0 : getDefaultWidth(index)) !== null && _ref1 !== void 0 ? _ref1 : \"1fr\";\n    let frozen = false;\n    let baseSize = 0;\n    let flex = 0;\n    let targetMainSize = null;\n    if ($6818b1c4fc67028d$export$1994a077b98ee0d5(width)) {\n      baseSize = $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, availableWidth);\n      frozen = true;\n    } else {\n      flex = $6818b1c4fc67028d$export$9078bad4c3934604(width);\n      if (flex <= 0) frozen = true;\n    }\n    var _column_minWidth, _ref2;\n    let min = $6818b1c4fc67028d$export$f556054ce4358701((_ref2 = (_column_minWidth = column.minWidth) !== null && _column_minWidth !== void 0 ? _column_minWidth : getDefaultMinWidth === null || getDefaultMinWidth === void 0 ? void 0 : getDefaultMinWidth(index)) !== null && _ref2 !== void 0 ? _ref2 : 0, availableWidth);\n    let max = $6818b1c4fc67028d$export$59185c62a7544aa0(column.maxWidth, availableWidth);\n    let hypotheticalMainSize = Math.max(min, Math.min(baseSize, max));\n    // 9.7.1\n    // We don't make use of flex basis, it's always 0, so we are always in 'grow' mode.\n    // 9.7.2\n    if (frozen) targetMainSize = hypotheticalMainSize;else if (baseSize > hypotheticalMainSize) {\n      frozen = true;\n      targetMainSize = hypotheticalMainSize;\n    }\n    // 9.7.3\n    if (!frozen) hasNonFrozenItems = true;\n    return {\n      frozen: frozen,\n      baseSize: baseSize,\n      hypotheticalMainSize: hypotheticalMainSize,\n      min: min,\n      max: max,\n      flex: flex,\n      targetMainSize: targetMainSize,\n      violation: 0\n    };\n  });\n  // 9.7.4\n  // 9.7.4.a\n  while (hasNonFrozenItems) {\n    // 9.7.4.b\n    /**\n    * Calculate the remaining free space as for initial free space,\n    * above (9.7.3). If the sum of the unfrozen flex items’ flex factors is\n    * less than one, multiply the initial free space by this sum (of flex factors).\n    * If the magnitude of this value is less than the magnitude of\n    * the remaining free space, use this as the remaining free space.\n    */\n    let usedWidth = 0;\n    let flexFactors = 0;\n    flexItems.forEach(item => {\n      if (item.frozen) usedWidth += item.targetMainSize;else {\n        usedWidth += item.baseSize;\n        flexFactors += item.flex;\n      }\n    });\n    let remainingFreeSpace = availableWidth - usedWidth;\n    // we only support integer FR's, and because of hasNonFrozenItems, we know that flexFactors > 0\n    // so no need to check for flexFactors < 1\n    // 9.7.4.c\n    /**\n    * If the remaining free space is zero\n    * - Do nothing.\n    * Else // remember, we're always in grow mode\n    * - Find the ratio of the item’s flex grow factor to the\n    * sum of the flex grow factors of all unfrozen items on\n    * the line. Set the item’s target main size to its flex\n    * base size plus a fraction of the remaining free space\n    * proportional to the ratio.\n    */\n    if (remainingFreeSpace > 0) flexItems.forEach(item => {\n      if (!item.frozen) {\n        let ratio = item.flex / flexFactors;\n        item.targetMainSize = item.baseSize + ratio * remainingFreeSpace;\n      }\n    });\n    // 9.7.4.d\n    /**\n    * Fix min/max violations. Clamp each non-frozen item’s\n    * target main size by its used min and max main sizes\n    * and floor its content-box size at zero. If the item’s\n    * target main size was made smaller by this, it’s a max\n    * violation. If the item’s target main size was made\n    * larger by this, it’s a min violation.\n    */\n    let totalViolation = 0;\n    flexItems.forEach(item => {\n      item.violation = 0;\n      if (!item.frozen) {\n        let {\n          min: min,\n          max: max,\n          targetMainSize: targetMainSize\n        } = item;\n        item.targetMainSize = Math.max(min, Math.min(targetMainSize, max));\n        item.violation = item.targetMainSize - targetMainSize;\n        totalViolation += item.violation;\n      }\n    });\n    // 9.7.4.e\n    /**\n    * Freeze over-flexed items. The total violation is the\n    * sum of the adjustments from the previous step\n    * ∑(clamped size - unclamped size). If the total violation is:\n    * Zero\n    * - Freeze all items.\n    *\n    * Positive\n    * - Freeze all the items with min violations.\n    *\n    * Negative\n    * - Freeze all the items with max violations.\n    */\n    hasNonFrozenItems = false;\n    flexItems.forEach(item => {\n      if (totalViolation === 0 || Math.sign(totalViolation) === Math.sign(item.violation)) item.frozen = true;else if (!item.frozen) hasNonFrozenItems = true;\n    });\n  }\n  return $6818b1c4fc67028d$var$cascadeRounding(flexItems);\n}\nfunction $6818b1c4fc67028d$var$cascadeRounding(flexItems) {\n  /*\n  Given an array of floats that sum to an integer, this rounds the floats\n  and returns an array of integers with the same sum.\n  */\n  let fpTotal = 0;\n  let intTotal = 0;\n  let roundedArray = [];\n  flexItems.forEach(function (item) {\n    let float = item.targetMainSize;\n    let integer = Math.round(float + fpTotal) - intTotal;\n    fpTotal += float;\n    intTotal += integer;\n    roundedArray.push(integer);\n  });\n  return roundedArray;\n}\nclass $a9e7ae544a4e41dd$export$7ff77a162970b30e {\n  /** Takes an array of columns and splits it into 2 maps of columns with controlled and columns with uncontrolled widths. */splitColumnsIntoControlledAndUncontrolled(columns) {\n    return columns.reduce((acc, col) => {\n      if (col.props.width != null) acc[0].set(col.key, col);else acc[1].set(col.key, col);\n      return acc;\n    }, [new Map(), new Map()]);\n  }\n  /** Takes uncontrolled and controlled widths and joins them into a single Map. */\n  recombineColumns(columns, uncontrolledWidths, uncontrolledColumns, controlledColumns) {\n    return new Map(columns.map(col => {\n      if (uncontrolledColumns.has(col.key)) return [col.key, uncontrolledWidths.get(col.key)];else return [col.key, controlledColumns.get(col.key).props.width];\n    }));\n  }\n  /** Used to make an initial Map of the uncontrolled widths based on default widths. */\n  getInitialUncontrolledWidths(uncontrolledColumns) {\n    return new Map(Array.from(uncontrolledColumns).map(([key, col]) => {\n      var _this_getDefaultWidth, _this;\n      var _col_props_defaultWidth, _ref;\n      return [key, (_ref = (_col_props_defaultWidth = col.props.defaultWidth) !== null && _col_props_defaultWidth !== void 0 ? _col_props_defaultWidth : (_this_getDefaultWidth = (_this = this).getDefaultWidth) === null || _this_getDefaultWidth === void 0 ? void 0 : _this_getDefaultWidth.call(_this, col)) !== null && _ref !== void 0 ? _ref : \"1fr\"];\n    }));\n  }\n  getColumnWidth(key) {\n    var _this_columnWidths_get;\n    return (_this_columnWidths_get = this.columnWidths.get(key)) !== null && _this_columnWidths_get !== void 0 ? _this_columnWidths_get : 0;\n  }\n  getColumnMinWidth(key) {\n    return this.columnMinWidths.get(key);\n  }\n  getColumnMaxWidth(key) {\n    return this.columnMaxWidths.get(key);\n  }\n  resizeColumnWidth(tableWidth, collection, controlledWidths, uncontrolledWidths, col = null, width) {\n    let prevColumnWidths = this.columnWidths;\n    // resizing a column\n    let resizeIndex = Infinity;\n    let resizingChanged = new Map([...controlledWidths, ...uncontrolledWidths]);\n    let percentKeys = new Map();\n    let frKeysToTheRight = new Map();\n    let minWidths = new Map();\n    // freeze columns to the left to their previous pixel value\n    collection.columns.forEach((column, i) => {\n      var _column_props_width_endsWith, _column_props_width;\n      let frKey;\n      let frValue;\n      minWidths.set(column.key, this.getDefaultMinWidth(collection.columns[i]));\n      if (col !== column.key && !column.props.width && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(uncontrolledWidths.get(column.key))) {\n        // uncontrolled don't have props.width for us, so instead get from our state\n        frKey = column.key;\n        frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(uncontrolledWidths.get(column.key));\n      } else if (col !== column.key && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(column.props.width) && !uncontrolledWidths.get(column.key)) {\n        // controlledWidths will be the same in the collection\n        frKey = column.key;\n        frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(column.props.width);\n      } else if (col !== column.key && ((_column_props_width = column.props.width) === null || _column_props_width === void 0 ? void 0 : (_column_props_width_endsWith = _column_props_width.endsWith) === null || _column_props_width_endsWith === void 0 ? void 0 : _column_props_width_endsWith.call(_column_props_width, \"%\"))) percentKeys.set(column.key, column.props.width);\n      // don't freeze columns to the right of the resizing one\n      if (resizeIndex < i) {\n        if (frKey) frKeysToTheRight.set(frKey, frValue);\n        return;\n      }\n      // we already know the new size of the resizing column\n      if (column.key === col) {\n        resizeIndex = i;\n        resizingChanged.set(column.key, Math.floor(width));\n        return;\n      }\n      // freeze column to previous value\n      resizingChanged.set(column.key, prevColumnWidths.get(column.key));\n    });\n    // predict pixels sizes for all columns based on resize\n    let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map(col => ({\n      ...col.props,\n      key: col.key\n    })), resizingChanged, i => this.getDefaultWidth(collection.columns[i]), i => this.getDefaultMinWidth(collection.columns[i]));\n    // set all new column widths for onResize event\n    // columns going in will be the same order as the columns coming out\n    let newWidths = new Map();\n    // set all column widths based on calculateColumnSize\n    columnWidths.forEach((width, index) => {\n      let key = collection.columns[index].key;\n      newWidths.set(key, width);\n    });\n    // add FR's back as they were to columns to the right\n    Array.from(frKeysToTheRight).forEach(([key]) => {\n      newWidths.set(key, `${frKeysToTheRight.get(key)}fr`);\n    });\n    // put back in percents\n    Array.from(percentKeys).forEach(([key, width]) => {\n      // resizing locks a column to a px width\n      if (key === col) return;\n      newWidths.set(key, width);\n    });\n    return newWidths;\n  }\n  buildColumnWidths(tableWidth, collection, widths) {\n    this.columnWidths = new Map();\n    this.columnMinWidths = new Map();\n    this.columnMaxWidths = new Map();\n    // initial layout or table/window resizing\n    let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map(col => ({\n      ...col.props,\n      key: col.key\n    })), widths, i => this.getDefaultWidth(collection.columns[i]), i => this.getDefaultMinWidth(collection.columns[i]));\n    // columns going in will be the same order as the columns coming out\n    columnWidths.forEach((width, index) => {\n      let key = collection.columns[index].key;\n      let column = collection.columns[index];\n      this.columnWidths.set(key, width);\n      var _column_props_minWidth;\n      this.columnMinWidths.set(key, (0, $6818b1c4fc67028d$export$f556054ce4358701)((_column_props_minWidth = column.props.minWidth) !== null && _column_props_minWidth !== void 0 ? _column_props_minWidth : this.getDefaultMinWidth(column), tableWidth));\n      this.columnMaxWidths.set(key, (0, $6818b1c4fc67028d$export$59185c62a7544aa0)(column.props.maxWidth, tableWidth));\n    });\n    return this.columnWidths;\n  }\n  constructor(options) {\n    this.columnWidths = new Map();\n    this.columnMinWidths = new Map();\n    this.columnMaxWidths = new Map();\n    var _options_getDefaultWidth;\n    this.getDefaultWidth = (_options_getDefaultWidth = options === null || options === void 0 ? void 0 : options.getDefaultWidth) !== null && _options_getDefaultWidth !== void 0 ? _options_getDefaultWidth : () => \"1fr\";\n    var _options_getDefaultMinWidth;\n    this.getDefaultMinWidth = (_options_getDefaultMinWidth = options === null || options === void 0 ? void 0 : options.getDefaultMinWidth) !== null && _options_getDefaultMinWidth !== void 0 ? _options_getDefaultMinWidth : () => 75;\n  }\n}\nfunction $292bc4e09cd0eb62$export$cb895dcf85db1319(props, state) {\n  let {\n    getDefaultWidth: getDefaultWidth,\n    getDefaultMinWidth: getDefaultMinWidth,\n    tableWidth = 0\n  } = props;\n  let [resizingColumn, setResizingColumn] = (0, $1BfjW$useState)(null);\n  let columnLayout = (0, $1BfjW$useMemo)(() => new (0, $a9e7ae544a4e41dd$export$7ff77a162970b30e)({\n    getDefaultWidth: getDefaultWidth,\n    getDefaultMinWidth: getDefaultMinWidth\n  }), [getDefaultWidth, getDefaultMinWidth]);\n  let [controlledColumns, uncontrolledColumns] = (0, $1BfjW$useMemo)(() => columnLayout.splitColumnsIntoControlledAndUncontrolled(state.collection.columns), [state.collection.columns, columnLayout]);\n  // uncontrolled column widths\n  let [uncontrolledWidths, setUncontrolledWidths] = (0, $1BfjW$useState)(() => columnLayout.getInitialUncontrolledWidths(uncontrolledColumns));\n  // Update uncontrolled widths if the columns changed.\n  let [lastColumns, setLastColumns] = (0, $1BfjW$useState)(state.collection.columns);\n  if (state.collection.columns !== lastColumns) {\n    if (state.collection.columns.length !== lastColumns.length || state.collection.columns.some((c, i) => c.key !== lastColumns[i].key)) {\n      let newUncontrolledWidths = columnLayout.getInitialUncontrolledWidths(uncontrolledColumns);\n      setUncontrolledWidths(newUncontrolledWidths);\n    }\n    setLastColumns(state.collection.columns);\n  }\n  // combine columns back into one map that maintains same order as the columns\n  let colWidths = (0, $1BfjW$useMemo)(() => columnLayout.recombineColumns(state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns), [state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns, columnLayout]);\n  let startResize = (0, $1BfjW$useCallback)(key => {\n    setResizingColumn(key);\n  }, [setResizingColumn]);\n  let updateResizedColumns = (0, $1BfjW$useCallback)((key, width) => {\n    let newControlled = new Map(Array.from(controlledColumns).map(([key, entry]) => [key, entry.props.width]));\n    let newSizes = columnLayout.resizeColumnWidth(tableWidth, state.collection, newControlled, uncontrolledWidths, key, width);\n    let map = new Map(Array.from(uncontrolledColumns).map(([key]) => [key, newSizes.get(key)]));\n    map.set(key, width);\n    setUncontrolledWidths(map);\n    return newSizes;\n  }, [controlledColumns, uncontrolledColumns, setUncontrolledWidths, tableWidth, columnLayout, state.collection, uncontrolledWidths]);\n  let endResize = (0, $1BfjW$useCallback)(() => {\n    setResizingColumn(null);\n  }, [setResizingColumn]);\n  (0, $1BfjW$useMemo)(() => columnLayout.buildColumnWidths(tableWidth, state.collection, colWidths), [tableWidth, state.collection, colWidths, columnLayout]);\n  return (0, $1BfjW$useMemo)(() => ({\n    resizingColumn: resizingColumn,\n    updateResizedColumns: updateResizedColumns,\n    startResize: startResize,\n    endResize: endResize,\n    getColumnWidth: key => columnLayout.getColumnWidth(key),\n    getColumnMinWidth: key => columnLayout.getColumnMinWidth(key),\n    getColumnMaxWidth: key => columnLayout.getColumnMaxWidth(key),\n    tableState: state\n  }), [columnLayout, resizingColumn, updateResizedColumns, startResize, endResize, state]);\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY = \"row-header-column-\" + Math.random().toString(36).slice(2);\nlet $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = \"row-header-column-\" + Math.random().toString(36).slice(2);\nwhile ($788781baa30117fa$var$ROW_HEADER_COLUMN_KEY === $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG) $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = \"row-header-column-\" + Math.random().toString(36).slice(2);\nfunction $788781baa30117fa$export$7c127db850d4e81e(keyMap, columnNodes) {\n  if (columnNodes.length === 0) return [];\n  let columns = [];\n  let seen = new Map();\n  for (let column of columnNodes) {\n    let parentKey = column.parentKey;\n    let col = [column];\n    while (parentKey) {\n      let parent = keyMap.get(parentKey);\n      if (!parent) break;\n      // If we've already seen this parent, than it is shared\n      // with a previous column. If the current column is taller\n      // than the previous column, than we need to shift the parent\n      // in the previous column so it's level with the current column.\n      if (seen.has(parent)) {\n        parent.colspan++;\n        let {\n          column: column,\n          index: index\n        } = seen.get(parent);\n        if (index > col.length) break;\n        for (let i = index; i < col.length; i++) column.splice(i, 0, null);\n        // Adjust shifted indices\n        for (let i = col.length; i < column.length; i++)\n        // eslint-disable-next-line max-depth\n        if (column[i] && seen.has(column[i])) seen.get(column[i]).index = i;\n      } else {\n        parent.colspan = 1;\n        col.push(parent);\n        seen.set(parent, {\n          column: col,\n          index: col.length - 1\n        });\n      }\n      parentKey = parent.parentKey;\n    }\n    columns.push(col);\n    column.index = columns.length - 1;\n  }\n  let maxLength = Math.max(...columns.map(c => c.length));\n  let headerRows = Array(maxLength).fill(0).map(() => []);\n  // Convert columns into rows.\n  let colIndex = 0;\n  for (let column of columns) {\n    let i = maxLength - 1;\n    for (let item of column) {\n      if (item) {\n        // Fill the space up until the current column with a placeholder\n        let row = headerRows[i];\n        let rowLength = row.reduce((p, c) => p + c.colspan, 0);\n        if (rowLength < colIndex) {\n          let placeholder = {\n            type: \"placeholder\",\n            key: \"placeholder-\" + item.key,\n            colspan: colIndex - rowLength,\n            index: rowLength,\n            value: null,\n            rendered: null,\n            level: i,\n            hasChildNodes: false,\n            childNodes: [],\n            textValue: null\n          };\n          // eslint-disable-next-line max-depth\n          if (row.length > 0) {\n            row[row.length - 1].nextKey = placeholder.key;\n            placeholder.prevKey = row[row.length - 1].key;\n          }\n          row.push(placeholder);\n        }\n        if (row.length > 0) {\n          row[row.length - 1].nextKey = item.key;\n          item.prevKey = row[row.length - 1].key;\n        }\n        item.level = i;\n        item.colIndex = colIndex;\n        row.push(item);\n      }\n      i--;\n    }\n    colIndex++;\n  }\n  // Add placeholders at the end of each row that is shorter than the maximum\n  let i = 0;\n  for (let row of headerRows) {\n    let rowLength = row.reduce((p, c) => p + c.colspan, 0);\n    if (rowLength < columnNodes.length) {\n      let placeholder = {\n        type: \"placeholder\",\n        key: \"placeholder-\" + row[row.length - 1].key,\n        colspan: columnNodes.length - rowLength,\n        index: rowLength,\n        value: null,\n        rendered: null,\n        level: i,\n        hasChildNodes: false,\n        childNodes: [],\n        textValue: null,\n        prevKey: row[row.length - 1].key\n      };\n      row.push(placeholder);\n    }\n    i++;\n  }\n  return headerRows.map((childNodes, index) => {\n    let row = {\n      type: \"headerrow\",\n      key: \"headerrow-\" + index,\n      index: index,\n      value: null,\n      rendered: null,\n      level: 0,\n      hasChildNodes: true,\n      childNodes: childNodes,\n      textValue: null\n    };\n    return row;\n  });\n}\nclass $788781baa30117fa$export$596e1b2e2cf93690 extends (0, $1BfjW$GridCollection) {\n  *[Symbol.iterator]() {\n    yield* this.body.childNodes;\n  }\n  get size() {\n    return this._size;\n  }\n  getKeys() {\n    return this.keyMap.keys();\n  }\n  getKeyBefore(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n  getKeyAfter(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n  getFirstKey() {\n    var _getFirstItem;\n    return (_getFirstItem = (0, $1BfjW$getFirstItem)(this.body.childNodes)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n  }\n  getLastKey() {\n    var _getLastItem;\n    return (_getLastItem = (0, $1BfjW$getLastItem)(this.body.childNodes)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;\n  }\n  getItem(key) {\n    return this.keyMap.get(key);\n  }\n  at(idx) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n  getTextValue(key) {\n    let row = this.getItem(key);\n    if (!row) return \"\";\n    // If the row has a textValue, use that.\n    if (row.textValue) return row.textValue;\n    // Otherwise combine the text of each of the row header columns.\n    let rowHeaderColumnKeys = this.rowHeaderColumnKeys;\n    if (rowHeaderColumnKeys) {\n      let text = [];\n      for (let cell of row.childNodes) {\n        let column = this.columns[cell.index];\n        if (rowHeaderColumnKeys.has(column.key) && cell.textValue) text.push(cell.textValue);\n        if (text.length === rowHeaderColumnKeys.size) break;\n      }\n      return text.join(\" \");\n    }\n    return \"\";\n  }\n  constructor(nodes, prev, opts) {\n    let rowHeaderColumnKeys = new Set();\n    let body;\n    let columns = [];\n    // Add cell for selection checkboxes if needed.\n    if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n      let rowHeaderColumn = {\n        type: \"column\",\n        key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY,\n        value: null,\n        textValue: \"\",\n        level: 0,\n        index: (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) ? 1 : 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isSelectionCell: true\n        }\n      };\n      columns.unshift(rowHeaderColumn);\n    }\n    // Add cell for drag buttons if needed.\n    if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) {\n      let rowHeaderColumn = {\n        type: \"column\",\n        key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG,\n        value: null,\n        textValue: \"\",\n        level: 0,\n        index: 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isDragButtonCell: true\n        }\n      };\n      columns.unshift(rowHeaderColumn);\n    }\n    let rows = [];\n    let columnKeyMap = new Map();\n    let visit = node => {\n      switch (node.type) {\n        case \"body\":\n          body = node;\n          break;\n        case \"column\":\n          columnKeyMap.set(node.key, node);\n          if (!node.hasChildNodes) {\n            columns.push(node);\n            if (node.props.isRowHeader) rowHeaderColumnKeys.add(node.key);\n          }\n          break;\n        case \"item\":\n          rows.push(node);\n          return;\n        // do not go into childNodes\n      }\n\n      for (let child of node.childNodes) visit(child);\n    };\n    for (let node of nodes) visit(node);\n    let headerRows = $788781baa30117fa$export$7c127db850d4e81e(columnKeyMap, columns);\n    headerRows.forEach((row, i) => rows.splice(i, 0, row));\n    super({\n      columnCount: columns.length,\n      items: rows,\n      visitNode: node => {\n        node.column = columns[node.index];\n        return node;\n      }\n    });\n    this._size = 0;\n    this.columns = columns;\n    this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n    this.body = body;\n    this.headerRows = headerRows;\n    this._size = [...body.childNodes].length;\n    // Default row header column to the first one.\n    if (this.rowHeaderColumnKeys.size === 0) {\n      if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n        if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) this.rowHeaderColumnKeys.add(this.columns[2].key);else this.rowHeaderColumnKeys.add(this.columns[1].key);\n      } else this.rowHeaderColumnKeys.add(this.columns[0].key);\n    }\n  }\n}\nconst $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION = {\n  ascending: \"descending\",\n  descending: \"ascending\"\n};\nfunction $4a0dd036d492cee4$export$907bcc6c48325fd6(props) {\n  let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = (0, $1BfjW$useState)(false);\n  let {\n    selectionMode = \"none\",\n    showSelectionCheckboxes: showSelectionCheckboxes,\n    showDragButtons: showDragButtons\n  } = props;\n  let context = (0, $1BfjW$useMemo)(() => ({\n    showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== \"none\",\n    showDragButtons: showDragButtons,\n    selectionMode: selectionMode,\n    columns: []\n  }), [props.children, showSelectionCheckboxes, selectionMode, showDragButtons]);\n  let collection = (0, $1BfjW$useCollection)(props, (0, $1BfjW$useCallback)(nodes => new (0, $788781baa30117fa$export$596e1b2e2cf93690)(nodes, null, context), [context]), context);\n  let {\n    disabledKeys: disabledKeys,\n    selectionManager: selectionManager\n  } = (0, $1BfjW$useGridState)({\n    ...props,\n    collection: collection,\n    disabledBehavior: props.disabledBehavior || \"selection\"\n  });\n  return {\n    collection: collection,\n    disabledKeys: disabledKeys,\n    selectionManager: selectionManager,\n    showSelectionCheckboxes: props.showSelectionCheckboxes || false,\n    sortDescriptor: props.sortDescriptor,\n    isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,\n    setKeyboardNavigationDisabled: setKeyboardNavigationDisabled,\n    sort(columnKey, direction) {\n      var _props_sortDescriptor;\n      props.onSortChange({\n        column: columnKey,\n        direction: direction !== null && direction !== void 0 ? direction : ((_props_sortDescriptor = props.sortDescriptor) === null || _props_sortDescriptor === void 0 ? void 0 : _props_sortDescriptor.column) === columnKey ? $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction] : \"ascending\"\n      });\n    }\n  };\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nfunction $312ae3b56a94a86e$var$TableHeader(props) {\n  return null;\n}\n$312ae3b56a94a86e$var$TableHeader.getCollectionNode = function* getCollectionNode(props, context) {\n  let {\n    children: children,\n    columns: columns\n  } = props;\n  // Clear columns so they aren't double added in strict mode.\n  context.columns = [];\n  if (typeof children === \"function\") {\n    if (!columns) throw new Error(\"props.children was a function but props.columns is missing\");\n    for (let column of columns) yield {\n      type: \"column\",\n      value: column,\n      renderer: children\n    };\n  } else {\n    let columns = [];\n    (0, $1BfjW$react).Children.forEach(children, column => {\n      columns.push({\n        type: \"column\",\n        element: column\n      });\n    });\n    yield* columns;\n  }\n};\n/**\n * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `columns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $312ae3b56a94a86e$export$f850895b287ef28e = $312ae3b56a94a86e$var$TableHeader;\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nfunction $4ae5314bf50db1a3$var$TableBody(props) {\n  return null;\n}\n$4ae5314bf50db1a3$var$TableBody.getCollectionNode = function* getCollectionNode(props) {\n  let {\n    children: children,\n    items: items\n  } = props;\n  yield {\n    type: \"body\",\n    hasChildNodes: true,\n    props: props,\n    *childNodes() {\n      if (typeof children === \"function\") {\n        if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n        for (let item of items) yield {\n          type: \"item\",\n          value: item,\n          renderer: children\n        };\n      } else {\n        let items = [];\n        (0, $1BfjW$react).Children.forEach(children, item => {\n          items.push({\n            type: \"item\",\n            element: item\n          });\n        });\n        yield* items;\n      }\n    }\n  };\n};\n/**\n * A TableBody is a container for the Row elements of a Table. Rows can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `items` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $4ae5314bf50db1a3$export$76ccd210b9029917 = $4ae5314bf50db1a3$var$TableBody;\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nfunction $1cd244557c2f97d5$var$Column(props) {\n  return null;\n}\n$1cd244557c2f97d5$var$Column.getCollectionNode = function* getCollectionNode(props, context) {\n  let {\n    title: title,\n    children: children,\n    childColumns: childColumns\n  } = props;\n  let rendered = title || children;\n  let textValue = props.textValue || (typeof rendered === \"string\" ? rendered : \"\") || props[\"aria-label\"];\n  let fullNodes = yield {\n    type: \"column\",\n    hasChildNodes: !!childColumns || title && (0, $1BfjW$react).Children.count(children) > 0,\n    rendered: rendered,\n    textValue: textValue,\n    props: props,\n    *childNodes() {\n      if (childColumns) for (let child of childColumns) yield {\n        type: \"column\",\n        value: child\n      };else if (title) {\n        let childColumns = [];\n        (0, $1BfjW$react).Children.forEach(children, child => {\n          childColumns.push({\n            type: \"column\",\n            element: child\n          });\n        });\n        yield* childColumns;\n      }\n    },\n    shouldInvalidate(newContext) {\n      // This is a bit of a hack, but it works.\n      // If this method is called, then there's a cached version of this node available.\n      // But, we need to keep the list of columns in the new context up to date.\n      updateContext(newContext);\n      return false;\n    }\n  };\n  let updateContext = context => {\n    // register leaf columns on the context so that <Row> can access them\n    for (let node of fullNodes) if (!node.hasChildNodes) context.columns.push(node);\n  };\n  updateContext(context);\n};\n/**\n * A Column represents a field of each item within a Table. Columns may also contain nested\n * Column elements to represent column groups. Nested columns can be statically defined as\n * children, or dynamically generated using a function based on the `childColumns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $1cd244557c2f97d5$export$816b5d811295e6bc = $1cd244557c2f97d5$var$Column;\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nfunction $70d70eb16ea48428$var$Row(props) {\n  return null;\n}\n$70d70eb16ea48428$var$Row.getCollectionNode = function* getCollectionNode(props, context) {\n  let {\n    children: children,\n    textValue: textValue,\n    UNSTABLE_childItems: UNSTABLE_childItems\n  } = props;\n  yield {\n    type: \"item\",\n    props: props,\n    textValue: textValue,\n    \"aria-label\": props[\"aria-label\"],\n    hasChildNodes: true,\n    *childNodes() {\n      // Process cells first\n      if (context.showDragButtons) yield {\n        type: \"cell\",\n        key: \"header-drag\",\n        props: {\n          isDragButtonCell: true\n        }\n      };\n      if (context.showSelectionCheckboxes && context.selectionMode !== \"none\") yield {\n        type: \"cell\",\n        key: \"header\",\n        props: {\n          isSelectionCell: true\n        }\n      };\n      if (typeof children === \"function\") {\n        for (let column of context.columns) yield {\n          type: \"cell\",\n          element: children(column.key),\n          key: column.key // this is combined with the row key by CollectionBuilder\n        };\n\n        if (UNSTABLE_childItems) for (let child of UNSTABLE_childItems)\n        // Note: in order to reuse the render function of TableBody for our child rows, we just need to yield a type and a value here. CollectionBuilder will then look up\n        // the parent renderer and use that to build the full node of this child row, using the value provided here to generate the cells\n        yield {\n          type: \"item\",\n          value: child\n        };\n      } else {\n        let cells = [];\n        let childRows = [];\n        (0, $1BfjW$react).Children.forEach(children, node => {\n          if (node.type === $70d70eb16ea48428$var$Row) {\n            if (cells.length < context.columns.length) throw new Error(\"All of a Row's child Cells must be positioned before any child Rows.\");\n            childRows.push({\n              type: \"item\",\n              element: node\n            });\n          } else cells.push({\n            type: \"cell\",\n            element: node\n          });\n        });\n        if (cells.length !== context.columns.length) throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);\n        yield* cells;\n        yield* childRows;\n      }\n    },\n    shouldInvalidate(newContext) {\n      // Invalidate all rows if the columns changed.\n      return newContext.columns.length !== context.columns.length || newContext.columns.some((c, i) => c.key !== context.columns[i].key) || newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes || newContext.showDragButtons !== context.showDragButtons || newContext.selectionMode !== context.selectionMode;\n    }\n  };\n};\n/**\n * A Row represents a single item in a Table and contains Cell elements for each column.\n * Cells can be statically defined as children, or generated dynamically using a function\n * based on the columns defined in the TableHeader.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $70d70eb16ea48428$export$b59bdbef9ce70de2 = $70d70eb16ea48428$var$Row;\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nfunction $941d1d9a6a28982a$var$Cell(props) {\n  return null;\n}\n$941d1d9a6a28982a$var$Cell.getCollectionNode = function* getCollectionNode(props) {\n  let {\n    children: children\n  } = props;\n  let textValue = props.textValue || (typeof children === \"string\" ? children : \"\") || props[\"aria-label\"] || \"\";\n  yield {\n    type: \"cell\",\n    props: props,\n    rendered: children,\n    textValue: textValue,\n    \"aria-label\": props[\"aria-label\"],\n    hasChildNodes: false\n  };\n};\n/**\n * A Cell represents the value of a single Column within a Table Row.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $941d1d9a6a28982a$export$f6f0c3fe4ec306ea = $941d1d9a6a28982a$var$Cell;\n\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $ee65a0057fd99531$export$34dfa8a1622185a4(props) {\n  let {\n    selectionMode = \"none\",\n    showSelectionCheckboxes: showSelectionCheckboxes,\n    showDragButtons: showDragButtons,\n    UNSTABLE_expandedKeys: propExpandedKeys,\n    UNSTABLE_defaultExpandedKeys: propDefaultExpandedKeys,\n    UNSTABLE_onExpandedChange: UNSTABLE_onExpandedChange,\n    children: children\n  } = props;\n  if (!(0, $1BfjW$tableNestedRows)()) throw new Error(\"Feature flag for table nested rows must be enabled to use useTreeGridState.\");\n  let [expandedKeys, setExpandedKeys] = (0, $1BfjW$useControlledState)(propExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propExpandedKeys) : undefined, propDefaultExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propDefaultExpandedKeys) : new Set(), UNSTABLE_onExpandedChange);\n  let context = (0, $1BfjW$useMemo)(() => ({\n    showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== \"none\",\n    showDragButtons: showDragButtons,\n    selectionMode: selectionMode,\n    columns: []\n  }), [children, showSelectionCheckboxes, selectionMode, showDragButtons]);\n  let builder = (0, $1BfjW$useMemo)(() => new (0, $1BfjW$CollectionBuilder)(), []);\n  let nodes = (0, $1BfjW$useMemo)(() => builder.build({\n    children: children\n  }, context), [builder, children, context]);\n  let treeGridCollection = (0, $1BfjW$useMemo)(() => {\n    return $ee65a0057fd99531$var$generateTreeGridCollection(nodes, {\n      showSelectionCheckboxes: showSelectionCheckboxes,\n      showDragButtons: showDragButtons,\n      expandedKeys: expandedKeys\n    });\n  }, [nodes, showSelectionCheckboxes, showDragButtons, expandedKeys]);\n  let onToggle = key => {\n    setExpandedKeys($ee65a0057fd99531$var$toggleKey(expandedKeys, key, treeGridCollection));\n  };\n  let collection = (0, $1BfjW$useMemo)(() => {\n    return new (0, $788781baa30117fa$export$596e1b2e2cf93690)(treeGridCollection.tableNodes, null, context);\n  }, [context, treeGridCollection.tableNodes]);\n  let tableState = (0, $4a0dd036d492cee4$export$907bcc6c48325fd6)({\n    ...props,\n    collection: collection\n  });\n  return {\n    ...tableState,\n    keyMap: treeGridCollection.keyMap,\n    userColumnCount: treeGridCollection.userColumnCount,\n    expandedKeys: expandedKeys,\n    toggleKey: onToggle\n  };\n}\nfunction $ee65a0057fd99531$var$toggleKey(currentExpandedKeys, key, collection) {\n  let updatedExpandedKeys;\n  if (currentExpandedKeys === \"all\") {\n    updatedExpandedKeys = new Set(collection.flattenedRows.filter(row => row.props.UNSTABLE_childItems || row.props.children.length > collection.userColumnCount).map(row => row.key));\n    updatedExpandedKeys.delete(key);\n  } else {\n    updatedExpandedKeys = new Set(currentExpandedKeys);\n    if (updatedExpandedKeys.has(key)) updatedExpandedKeys.delete(key);else updatedExpandedKeys.add(key);\n  }\n  return updatedExpandedKeys;\n}\nfunction $ee65a0057fd99531$var$convertExpanded(expanded) {\n  if (!expanded) return new Set();\n  return expanded === \"all\" ? \"all\" : new Set(expanded);\n}\nfunction $ee65a0057fd99531$var$generateTreeGridCollection(nodes, opts) {\n  let {\n    expandedKeys = new Set()\n  } = opts;\n  let body;\n  let flattenedRows = [];\n  let columnCount = 0;\n  let userColumnCount = 0;\n  let originalColumns = [];\n  let keyMap = new Map();\n  if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) columnCount++;\n  if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) columnCount++;\n  let topLevelRows = [];\n  let visit = node => {\n    switch (node.type) {\n      case \"body\":\n        body = node;\n        keyMap.set(body.key, body);\n        break;\n      case \"column\":\n        if (!node.hasChildNodes) userColumnCount++;\n        break;\n      case \"item\":\n        topLevelRows.push(node);\n        return;\n    }\n    for (let child of node.childNodes) visit(child);\n  };\n  for (let node of nodes) {\n    if (node.type === \"column\") originalColumns.push(node);\n    visit(node);\n  }\n  columnCount += userColumnCount;\n  // Update each grid node in the treegrid table with values specific to a treegrid structure. Also store a set of flattened row nodes for TableCollection to consume\n  let globalRowCount = 0;\n  let visitNode = (node, i) => {\n    // Clone row node and its children so modifications to the node for treegrid specific values aren't applied on the nodes provided\n    // to TableCollection. Index, level, and parent keys are all changed to reflect a flattened row structure rather than the treegrid structure\n    // values automatically calculated via CollectionBuilder\n    if (node.type === \"item\") {\n      let childNodes = [];\n      for (let child of node.childNodes) if (child.type === \"cell\") {\n        let cellClone = {\n          ...child\n        };\n        if (cellClone.index + 1 === columnCount) cellClone.nextKey = null;\n        childNodes.push({\n          ...cellClone\n        });\n      }\n      let clone = {\n        ...node,\n        childNodes: childNodes,\n        parentKey: body.key,\n        level: 1,\n        index: globalRowCount++\n      };\n      flattenedRows.push(clone);\n    }\n    let newProps = {};\n    // Assign indexOfType to cells and rows for aria-posinset\n    if (node.type !== \"placeholder\" && node.type !== \"column\") newProps[\"indexOfType\"] = i;\n    // Use Object.assign instead of spread to preserve object reference for keyMap. Also ensures retrieving nodes\n    // via .childNodes returns the same object as the one found via keyMap look up\n    Object.assign(node, newProps);\n    keyMap.set(node.key, node);\n    let lastNode;\n    let rowIndex = 0;\n    for (let child of node.childNodes) if (!(child.type === \"item\" && expandedKeys !== \"all\" && !expandedKeys.has(node.key))) {\n      if (child.parentKey == null)\n        // if child is a cell/expanded row/column and the parent key isn't already established by the collection, match child node to parent row\n        child.parentKey = node.key;\n      if (lastNode) {\n        lastNode.nextKey = child.key;\n        child.prevKey = lastNode.key;\n      } else child.prevKey = null;\n      if (child.type === \"item\") visitNode(child, rowIndex++);else\n        // We enforce that the cells come before rows so can just reuse cell index\n        visitNode(child, child.index);\n      lastNode = child;\n    }\n    if (lastNode) lastNode.nextKey = null;\n  };\n  let last;\n  topLevelRows.forEach((node, i) => {\n    visitNode(node, i);\n    if (last) {\n      last.nextKey = node.key;\n      node.prevKey = last.key;\n    } else node.prevKey = null;\n    last = node;\n  });\n  if (last) last.nextKey = null;\n  return {\n    keyMap: keyMap,\n    userColumnCount: userColumnCount,\n    flattenedRows: flattenedRows,\n    tableNodes: [...originalColumns, {\n      ...body,\n      childNodes: flattenedRows\n    }]\n  };\n}\nexport { $292bc4e09cd0eb62$export$cb895dcf85db1319 as useTableColumnResizeState, $4a0dd036d492cee4$export$907bcc6c48325fd6 as useTableState, $312ae3b56a94a86e$export$f850895b287ef28e as TableHeader, $4ae5314bf50db1a3$export$76ccd210b9029917 as TableBody, $1cd244557c2f97d5$export$816b5d811295e6bc as Column, $70d70eb16ea48428$export$b59bdbef9ce70de2 as Row, $941d1d9a6a28982a$export$f6f0c3fe4ec306ea as Cell, $6555104ff085bef4$re_export$Section as Section, $788781baa30117fa$export$596e1b2e2cf93690 as TableCollection, $788781baa30117fa$export$7c127db850d4e81e as buildHeaderRows, $a9e7ae544a4e41dd$export$7ff77a162970b30e as TableColumnLayout, $ee65a0057fd99531$export$34dfa8a1622185a4 as UNSTABLE_useTreeGridState };","map":{"version":3,"names":["$6818b1c4fc67028d$export$1994a077b98ee0d5","width","isNaN","String","match","$6818b1c4fc67028d$export$9078bad4c3934604","console","warn","parseFloat","$6818b1c4fc67028d$export$7bbad27896f7ae9f","tableWidth","Error","$6818b1c4fc67028d$export$59185c62a7544aa0","maxWidth","Number","MAX_SAFE_INTEGER","$6818b1c4fc67028d$export$f556054ce4358701","minWidth","$6818b1c4fc67028d$export$55d50dc687385491","availableWidth","columns","changedColumns","getDefaultWidth","getDefaultMinWidth","hasNonFrozenItems","flexItems","map","column","index","_column_width","_ref","_ref1","get","key","defaultWidth","frozen","baseSize","flex","targetMainSize","_column_minWidth","_ref2","min","max","hypotheticalMainSize","Math","violation","usedWidth","flexFactors","forEach","item","remainingFreeSpace","ratio","totalViolation","sign","$6818b1c4fc67028d$var$cascadeRounding","fpTotal","intTotal","roundedArray","float","integer","round","push","$a9e7ae544a4e41dd$export$7ff77a162970b30e","splitColumnsIntoControlledAndUncontrolled","reduce","acc","col","props","set","Map","recombineColumns","uncontrolledWidths","uncontrolledColumns","controlledColumns","has","getInitialUncontrolledWidths","Array","from","_this_getDefaultWidth","_this","_col_props_defaultWidth","call","getColumnWidth","_this_columnWidths_get","columnWidths","getColumnMinWidth","columnMinWidths","getColumnMaxWidth","columnMaxWidths","resizeColumnWidth","collection","controlledWidths","prevColumnWidths","resizeIndex","Infinity","resizingChanged","percentKeys","frKeysToTheRight","minWidths","i","_column_props_width_endsWith","_column_props_width","frKey","frValue","endsWith","floor","newWidths","buildColumnWidths","widths","_column_props_minWidth","constructor","options","_options_getDefaultWidth","_options_getDefaultMinWidth","$292bc4e09cd0eb62$export$cb895dcf85db1319","state","resizingColumn","setResizingColumn","$1BfjW$useState","columnLayout","$1BfjW$useMemo","setUncontrolledWidths","lastColumns","setLastColumns","length","some","c","newUncontrolledWidths","colWidths","startResize","$1BfjW$useCallback","updateResizedColumns","newControlled","entry","newSizes","endResize","tableState","$788781baa30117fa$var$ROW_HEADER_COLUMN_KEY","random","toString","slice","$788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG","$788781baa30117fa$export$7c127db850d4e81e","keyMap","columnNodes","seen","parentKey","parent","colspan","splice","maxLength","headerRows","fill","colIndex","row","rowLength","p","placeholder","type","value","rendered","level","hasChildNodes","childNodes","textValue","nextKey","prevKey","$788781baa30117fa$export$596e1b2e2cf93690","$1BfjW$GridCollection","Symbol","iterator","body","size","_size","getKeys","keys","getKeyBefore","node","getKeyAfter","getFirstKey","_getFirstItem","$1BfjW$getFirstItem","getLastKey","_getLastItem","$1BfjW$getLastItem","getItem","at","idx","getTextValue","rowHeaderColumnKeys","text","cell","join","nodes","prev","opts","Set","showSelectionCheckboxes","rowHeaderColumn","showDragButtons","isSelectionCell","unshift","isDragButtonCell","rows","columnKeyMap","visit","isRowHeader","add","child","columnCount","items","visitNode","$4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION","ascending","descending","$4a0dd036d492cee4$export$907bcc6c48325fd6","isKeyboardNavigationDisabled","setKeyboardNavigationDisabled","selectionMode","context","children","$1BfjW$useCollection","disabledKeys","selectionManager","$1BfjW$useGridState","disabledBehavior","sortDescriptor","sort","columnKey","direction","_props_sortDescriptor","onSortChange","$312ae3b56a94a86e$var$TableHeader","getCollectionNode","renderer","$1BfjW$react","Children","element","$312ae3b56a94a86e$export$f850895b287ef28e","$4ae5314bf50db1a3$var$TableBody","$4ae5314bf50db1a3$export$76ccd210b9029917","$1cd244557c2f97d5$var$Column","title","childColumns","fullNodes","count","shouldInvalidate","newContext","updateContext","$1cd244557c2f97d5$export$816b5d811295e6bc","$70d70eb16ea48428$var$Row","UNSTABLE_childItems","cells","childRows","$70d70eb16ea48428$export$b59bdbef9ce70de2","$941d1d9a6a28982a$var$Cell","$941d1d9a6a28982a$export$f6f0c3fe4ec306ea","$ee65a0057fd99531$export$34dfa8a1622185a4","UNSTABLE_expandedKeys","propExpandedKeys","UNSTABLE_defaultExpandedKeys","propDefaultExpandedKeys","UNSTABLE_onExpandedChange","$1BfjW$tableNestedRows","expandedKeys","setExpandedKeys","$1BfjW$useControlledState","$ee65a0057fd99531$var$convertExpanded","undefined","builder","$1BfjW$CollectionBuilder","build","treeGridCollection","$ee65a0057fd99531$var$generateTreeGridCollection","onToggle","$ee65a0057fd99531$var$toggleKey","tableNodes","userColumnCount","toggleKey","currentExpandedKeys","updatedExpandedKeys","flattenedRows","filter","delete","expanded","originalColumns","topLevelRows","globalRowCount","cellClone","clone","newProps","Object","assign","lastNode","rowIndex","last"],"sources":["C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\table\\dist\\packages\\@react-stately\\table\\src\\index.ts","C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\table\\dist\\packages\\@react-stately\\table\\src\\useTableColumnResizeState.ts","C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\table\\dist\\packages\\@react-stately\\table\\src\\TableColumnLayout.ts","C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\table\\dist\\packages\\@react-stately\\table\\src\\TableUtils.ts","C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\table\\dist\\packages\\@react-stately\\table\\src\\useTableState.ts","C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\table\\dist\\packages\\@react-stately\\table\\src\\TableCollection.ts","C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\table\\dist\\packages\\@react-stately\\table\\src\\TableHeader.ts","C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\table\\dist\\packages\\@react-stately\\table\\src\\TableBody.ts","C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\table\\dist\\packages\\@react-stately\\table\\src\\Column.ts","C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\table\\dist\\packages\\@react-stately\\table\\src\\Row.ts","C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\table\\dist\\packages\\@react-stately\\table\\src\\Cell.ts","C:\\Users\\joelp\\csc-307-achieveit\\AchieveIt\\node_modules\\@react-stately\\table\\dist\\packages\\@react-stately\\table\\src\\useTreeGridState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport type {TableColumnResizeState, TableColumnResizeStateProps} from './useTableColumnResizeState';\nexport type {TableState, CollectionBuilderContext, TableStateProps} from './useTableState';\nexport type {TableHeaderProps, TableBodyProps, ColumnProps, RowProps, CellProps} from '@react-types/table';\nexport type {TreeGridState, TreeGridStateProps} from './useTreeGridState';\n\nexport {useTableColumnResizeState} from './useTableColumnResizeState';\nexport {useTableState} from './useTableState';\nexport {TableHeader} from './TableHeader';\nexport {TableBody} from './TableBody';\nexport {Column} from './Column';\nexport {Row} from './Row';\nexport {Cell} from './Cell';\nexport {Section} from '@react-stately/collections';\nexport {TableCollection, buildHeaderRows} from './TableCollection';\nexport {TableColumnLayout} from './TableColumnLayout';\nexport {UNSTABLE_useTreeGridState} from './useTreeGridState';\n","/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {ColumnSize} from '@react-types/table';\nimport {GridNode} from '@react-types/grid';\nimport {Key} from '@react-types/shared';\nimport {TableColumnLayout} from './TableColumnLayout';\nimport {TableState} from './useTableState';\nimport {useCallback, useMemo, useState} from 'react';\n\nexport interface TableColumnResizeStateProps<T> {\n  /**\n   * Current width of the table or table viewport that the columns\n   * should be calculated against.\n   */\n  tableWidth: number,\n  /** A function that is called to find the default width for a given column. */\n  getDefaultWidth?: (node: GridNode<T>) => ColumnSize | null | undefined,\n  /** A function that is called to find the default minWidth for a given column. */\n  getDefaultMinWidth?: (node: GridNode<T>) => ColumnSize | null | undefined\n}\nexport interface TableColumnResizeState<T> {\n  /**\n   * Called to update the state that a resize event has occurred.\n   * Returns the new widths for all columns based on the resized column.\n   */\n  updateResizedColumns: (key: Key, width: number) => Map<Key, ColumnSize>,\n  /** Callback for when onColumnResize has started. */\n  startResize: (key: Key) => void,\n  /** Callback for when onColumnResize has ended. */\n  endResize: () => void,\n  /** Gets the current width for the specified column. */\n  getColumnWidth: (key: Key) => number,\n  /** Gets the current minWidth for the specified column. */\n  getColumnMinWidth: (key: Key) => number,\n  /** Gets the current maxWidth for the specified column. */\n  getColumnMaxWidth: (key: Key) => number,\n  /** Key of the currently resizing column. */\n  resizingColumn: Key | null,\n  /** A reference to the table state. */\n  tableState: TableState<T>\n}\n\n/**\n * Provides column width state management for a table component with column resizing support. Handles building\n * a map of column widths calculated from the table's width and any provided column width information from the collection.\n * In addition, it tracks the currently resizing column and provides callbacks for updating the widths upon resize operations.\n * @param props - Props for the table.\n * @param state - State for the table, as returned by `useTableState`.\n */\nexport function useTableColumnResizeState<T>(props: TableColumnResizeStateProps<T>, state: TableState<T>): TableColumnResizeState<T> {\n  let {\n    getDefaultWidth,\n    getDefaultMinWidth,\n    tableWidth = 0\n  } = props;\n\n  let [resizingColumn, setResizingColumn] = useState<Key | null>(null);\n  let columnLayout = useMemo(\n    () => new TableColumnLayout({\n      getDefaultWidth,\n      getDefaultMinWidth\n    }),\n    [getDefaultWidth, getDefaultMinWidth]\n  );\n\n  let [controlledColumns, uncontrolledColumns] = useMemo(() =>\n      columnLayout.splitColumnsIntoControlledAndUncontrolled(state.collection.columns)\n  , [state.collection.columns, columnLayout]);\n\n  // uncontrolled column widths\n  let [uncontrolledWidths, setUncontrolledWidths] = useState(() =>\n    columnLayout.getInitialUncontrolledWidths(uncontrolledColumns)\n  );\n\n  // Update uncontrolled widths if the columns changed.\n  let [lastColumns, setLastColumns] = useState(state.collection.columns);\n  if (state.collection.columns !== lastColumns) {\n    if (\n      state.collection.columns.length !== lastColumns.length ||\n      state.collection.columns.some((c, i) => c.key !== lastColumns[i].key)\n    ) {\n      let newUncontrolledWidths = columnLayout.getInitialUncontrolledWidths(uncontrolledColumns);\n      setUncontrolledWidths(newUncontrolledWidths);\n    }\n    setLastColumns(state.collection.columns);\n  }\n\n  // combine columns back into one map that maintains same order as the columns\n  let colWidths = useMemo(() =>\n      columnLayout.recombineColumns(state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns)\n  , [state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns, columnLayout]);\n\n  let startResize = useCallback((key: Key) => {\n    setResizingColumn(key);\n  }, [setResizingColumn]);\n\n  let updateResizedColumns = useCallback((key: Key, width: number): Map<Key, ColumnSize> => {\n    let newControlled = new Map(Array.from(controlledColumns).map(([key, entry]) => [key, entry.props.width]));\n    let newSizes = columnLayout.resizeColumnWidth(tableWidth, state.collection, newControlled, uncontrolledWidths, key, width);\n\n    let map = new Map(Array.from(uncontrolledColumns).map(([key]) => [key, newSizes.get(key)]));\n    map.set(key, width);\n    setUncontrolledWidths(map);\n    return newSizes;\n  }, [controlledColumns, uncontrolledColumns, setUncontrolledWidths, tableWidth, columnLayout, state.collection, uncontrolledWidths]);\n\n  let endResize = useCallback(() => {\n    setResizingColumn(null);\n  }, [setResizingColumn]);\n\n  useMemo(() =>\n    columnLayout.buildColumnWidths(tableWidth, state.collection, colWidths)\n  , [tableWidth, state.collection, colWidths, columnLayout]);\n\n  return useMemo(() => ({\n    resizingColumn,\n    updateResizedColumns,\n    startResize,\n    endResize,\n    getColumnWidth: (key: Key) =>\n      columnLayout.getColumnWidth(key),\n    getColumnMinWidth: (key: Key) =>\n      columnLayout.getColumnMinWidth(key),\n    getColumnMaxWidth: (key: Key) =>\n      columnLayout.getColumnMaxWidth(key),\n    tableState: state\n  }), [\n    columnLayout,\n    resizingColumn,\n    updateResizedColumns,\n    startResize,\n    endResize,\n    state\n  ]);\n}\n","/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  calculateColumnSizes,\n  getMaxWidth,\n  getMinWidth,\n  isStatic,\n  parseFractionalUnit\n} from './TableUtils';\nimport {ColumnSize, TableCollection} from '@react-types/table';\nimport {GridNode} from '@react-types/grid';\nimport {Key} from '@react-types/shared';\n\nexport interface TableColumnLayoutOptions<T> {\n  getDefaultWidth?: (column: GridNode<T>) => ColumnSize | null | undefined,\n  getDefaultMinWidth?: (column: GridNode<T>) => ColumnSize | null | undefined\n}\n\nexport class TableColumnLayout<T> {\n  getDefaultWidth: (column: GridNode<T>) => ColumnSize | null | undefined;\n  getDefaultMinWidth: (column: GridNode<T>) => ColumnSize | null | undefined;\n  columnWidths: Map<Key, number> = new Map();\n  columnMinWidths: Map<Key, number> = new Map();\n  columnMaxWidths: Map<Key, number> = new Map();\n\n  constructor(options: TableColumnLayoutOptions<T>) {\n    this.getDefaultWidth = options?.getDefaultWidth ?? (() => '1fr');\n    this.getDefaultMinWidth = options?.getDefaultMinWidth ?? (() => 75);\n  }\n\n  /** Takes an array of columns and splits it into 2 maps of columns with controlled and columns with uncontrolled widths. */\n  splitColumnsIntoControlledAndUncontrolled(columns: Array<GridNode<T>>): [Map<Key, GridNode<T>>, Map<Key, GridNode<T>>] {\n    return columns.reduce((acc, col) => {\n      if (col.props.width != null) {\n        acc[0].set(col.key, col);\n      } else {\n        acc[1].set(col.key, col);\n      }\n      return acc;\n    }, [new Map(), new Map()]);\n  }\n\n  /** Takes uncontrolled and controlled widths and joins them into a single Map. */\n  recombineColumns(columns: Array<GridNode<T>>, uncontrolledWidths: Map<Key, ColumnSize>, uncontrolledColumns: Map<Key, GridNode<T>>, controlledColumns: Map<Key, GridNode<T>>): Map<Key, ColumnSize> {\n    return new Map(columns.map(col => {\n      if (uncontrolledColumns.has(col.key)) {\n        return [col.key, uncontrolledWidths.get(col.key)];\n      } else {\n        return [col.key, controlledColumns.get(col.key).props.width];\n      }\n    }));\n  }\n\n  /** Used to make an initial Map of the uncontrolled widths based on default widths. */\n  getInitialUncontrolledWidths(uncontrolledColumns: Map<Key, GridNode<T>>): Map<Key, ColumnSize> {\n    return new Map(Array.from(uncontrolledColumns).map(([key, col]) =>\n      [key, col.props.defaultWidth ?? this.getDefaultWidth?.(col) ?? '1fr']\n    ));\n  }\n\n  getColumnWidth(key: Key): number {\n    return this.columnWidths.get(key) ?? 0;\n  }\n\n  getColumnMinWidth(key: Key): number {\n    return this.columnMinWidths.get(key);\n  }\n\n  getColumnMaxWidth(key: Key): number {\n    return this.columnMaxWidths.get(key);\n  }\n\n  resizeColumnWidth(tableWidth: number, collection: TableCollection<T>, controlledWidths: Map<Key, ColumnSize>, uncontrolledWidths: Map<Key, ColumnSize>, col = null, width: number): Map<Key, ColumnSize> {\n    let prevColumnWidths = this.columnWidths;\n    // resizing a column\n    let resizeIndex = Infinity;\n    let resizingChanged = new Map<Key, ColumnSize>([...controlledWidths, ...uncontrolledWidths]);\n    let percentKeys = new Map();\n    let frKeysToTheRight = new Map();\n    let minWidths = new Map();\n    // freeze columns to the left to their previous pixel value\n    collection.columns.forEach((column, i) => {\n      let frKey;\n      let frValue;\n      minWidths.set(column.key, this.getDefaultMinWidth(collection.columns[i]));\n      if (col !== column.key && !column.props.width && !isStatic(uncontrolledWidths.get(column.key))) {\n        // uncontrolled don't have props.width for us, so instead get from our state\n        frKey = column.key;\n        frValue = parseFractionalUnit(uncontrolledWidths.get(column.key) as string);\n      } else if (col !== column.key && !isStatic(column.props.width) && !uncontrolledWidths.get(column.key)) {\n        // controlledWidths will be the same in the collection\n        frKey = column.key;\n        frValue = parseFractionalUnit(column.props.width);\n      } else if (col !== column.key && column.props.width?.endsWith?.('%')) {\n        percentKeys.set(column.key, column.props.width);\n      }\n      // don't freeze columns to the right of the resizing one\n      if (resizeIndex < i) {\n        if (frKey) {\n          frKeysToTheRight.set(frKey, frValue);\n        }\n        return;\n      }\n      // we already know the new size of the resizing column\n      if (column.key === col) {\n        resizeIndex = i;\n        resizingChanged.set(column.key, Math.floor(width));\n        return;\n      }\n      // freeze column to previous value\n      resizingChanged.set(column.key, prevColumnWidths.get(column.key));\n    });\n\n    // predict pixels sizes for all columns based on resize\n    let columnWidths = calculateColumnSizes(\n      tableWidth,\n      collection.columns.map(col => ({...col.props, key: col.key})),\n      resizingChanged,\n      (i) => this.getDefaultWidth(collection.columns[i]),\n      (i) => this.getDefaultMinWidth(collection.columns[i])\n    );\n\n    // set all new column widths for onResize event\n    // columns going in will be the same order as the columns coming out\n    let newWidths = new Map<Key, ColumnSize>();\n    // set all column widths based on calculateColumnSize\n    columnWidths.forEach((width, index) => {\n      let key = collection.columns[index].key;\n      newWidths.set(key, width);\n    });\n\n    // add FR's back as they were to columns to the right\n    Array.from(frKeysToTheRight).forEach(([key]) => {\n      newWidths.set(key, `${frKeysToTheRight.get(key)}fr`);\n    });\n\n    // put back in percents\n    Array.from(percentKeys).forEach(([key, width]) => {\n      // resizing locks a column to a px width\n      if (key === col) {\n        return;\n      }\n      newWidths.set(key, width);\n    });\n    return newWidths;\n  }\n\n  buildColumnWidths(tableWidth: number, collection: TableCollection<T>, widths: Map<Key, ColumnSize>) {\n    this.columnWidths = new Map();\n    this.columnMinWidths = new Map();\n    this.columnMaxWidths = new Map();\n\n    // initial layout or table/window resizing\n    let columnWidths = calculateColumnSizes(\n      tableWidth,\n      collection.columns.map(col => ({...col.props, key: col.key})),\n      widths,\n      (i) => this.getDefaultWidth(collection.columns[i]),\n      (i) => this.getDefaultMinWidth(collection.columns[i])\n    );\n\n    // columns going in will be the same order as the columns coming out\n    columnWidths.forEach((width, index) => {\n      let key = collection.columns[index].key;\n      let column = collection.columns[index];\n      this.columnWidths.set(key, width);\n      this.columnMinWidths.set(key, getMinWidth(column.props.minWidth ?? this.getDefaultMinWidth(column), tableWidth));\n      this.columnMaxWidths.set(key, getMaxWidth(column.props.maxWidth, tableWidth));\n    });\n    return this.columnWidths;\n  }\n}\n","/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {ColumnSize} from '@react-types/table';\nimport {Key} from '@react-types/shared';\n\n// numbers and percents are considered static. *fr units or a lack of units are considered dynamic.\nexport function isStatic(width: number | string): boolean {\n  return width != null && (!isNaN(width as number) || (String(width)).match(/^(\\d+)(?=%$)/) !== null);\n}\n\nexport function parseFractionalUnit(width: string): number {\n  if (!width) {\n    return 1;\n  }\n  let match = width.match(/^(.+)(?=fr$)/);\n  // if width is the incorrect format, just default it to a 1fr\n  if (!match) {\n    console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`,\n      'defaulting to \\'1fr\\'');\n    return 1;\n  }\n  return parseFloat(match[0]);\n}\n\nexport function parseStaticWidth(width: number | string, tableWidth: number): number {\n  if (typeof width === 'string') {\n    let match = width.match(/^(\\d+)(?=%$)/);\n    if (!match) {\n      throw new Error('Only percentages or numbers are supported for static column widths');\n    }\n    return tableWidth * (parseFloat(match[0]) / 100);\n  }\n  return width;\n}\n\n\nexport function getMaxWidth(maxWidth: number | string, tableWidth: number): number {\n  return maxWidth != null\n    ? parseStaticWidth(maxWidth, tableWidth)\n    : Number.MAX_SAFE_INTEGER;\n}\n\n// cannot support FR units, we'd need to know everything else in the table to do that\nexport function getMinWidth(minWidth: number | string, tableWidth: number): number {\n  return minWidth != null\n    ? parseStaticWidth(minWidth, tableWidth)\n    : 0;\n}\n\n\nexport interface IColumn {\n  minWidth?: number | string,\n  maxWidth?: number | string,\n  width?: number | string,\n  defaultWidth?: number | string,\n  key?: Key\n}\n\n/**\n * Implements the flex algorithm described in https://www.w3.org/TR/css-flexbox-1/#layout-algorithm\n * It makes a few constraint/assumptions:\n * 1. All basis values are 0 unless it is a static width, then the basis is the static width\n * 2. All flex grow and shrink values are equal to the FR specified on the column, grow and shrink for the same column are equal\n * 3. We only have one row\n * An example of the setup can be seen here https://jsfiddle.net/snowystinger/wv0ymjaf/61/ where I let the browser figure out the\n * flex of the columns.\n * Note: We differ in one key aspect, all of our column widths must be whole numbers, so we avoid browser\n * sub pixel rounding errors. To do this, we use a cascading rounding algorithm to ensure that the sum of the widths is maintained\n * while distributing the rounding remainder across the columns.\n *\n * As noted in the chrome source code, this algorithm is very accurate, but has the potential to be quadratic.\n * They have deemed this to be acceptable because the number of elements is usually small and the flex factors\n * are usually not high variance. I believe we can make the same assumptions. Particularly once resizing is\n * started, it will convert all columns to the left to static widths, so it will cut down on the number of FR columns.\n *\n * There are likely faster ways to do this, I've chosen to stick to the spec as closely as possible for readability, accuracy, and for the\n * note that this behaving quadratically is unlikely to be a problem.\n * @param availableWidth - The visible width of the table.\n * @param columns - The table defined columns.\n * @param changedColumns - Any columns we want to override, for example, during resizing.\n * @param getDefaultWidth - A function that returns the default width of a column by its index.\n * @param getDefaultMinWidth - A function that returns the default min width of a column by its index.\n */\nexport function calculateColumnSizes(availableWidth: number, columns: IColumn[], changedColumns: Map<Key, ColumnSize>, getDefaultWidth, getDefaultMinWidth) {\n  let hasNonFrozenItems = false;\n  let flexItems = columns.map((column, index) => {\n    let width = changedColumns.get(column.key) != null ? changedColumns.get(column.key) : column.width ?? column.defaultWidth ?? getDefaultWidth?.(index) ?? '1fr';\n    let frozen = false;\n    let baseSize = 0;\n    let flex = 0;\n    let targetMainSize = null;\n    if (isStatic(width)) {\n      baseSize = parseStaticWidth(width, availableWidth);\n      frozen = true;\n    } else {\n      flex = parseFractionalUnit(width);\n      if (flex <= 0) {\n        frozen = true;\n      }\n    }\n\n    let min = getMinWidth(column.minWidth ?? getDefaultMinWidth?.(index) ?? 0, availableWidth);\n    let max = getMaxWidth(column.maxWidth, availableWidth);\n    let hypotheticalMainSize = Math.max(min, Math.min(baseSize, max));\n\n    // 9.7.1\n    // We don't make use of flex basis, it's always 0, so we are always in 'grow' mode.\n    // 9.7.2\n    if (frozen) {\n      targetMainSize = hypotheticalMainSize;\n    } else if (baseSize > hypotheticalMainSize) {\n      frozen = true;\n      targetMainSize = hypotheticalMainSize;\n    }\n\n    // 9.7.3\n    if (!frozen) {\n      hasNonFrozenItems = true;\n    }\n    return {\n      frozen,\n      baseSize,\n      hypotheticalMainSize,\n      min,\n      max,\n      flex,\n      targetMainSize,\n      violation: 0\n    };\n  });\n\n  // 9.7.4\n  // 9.7.4.a\n  while (hasNonFrozenItems) {\n    // 9.7.4.b\n    /**\n     * Calculate the remaining free space as for initial free space,\n     * above (9.7.3). If the sum of the unfrozen flex items’ flex factors is\n     * less than one, multiply the initial free space by this sum (of flex factors).\n     * If the magnitude of this value is less than the magnitude of\n     * the remaining free space, use this as the remaining free space.\n     */\n    let usedWidth = 0;\n    let flexFactors = 0;\n    flexItems.forEach(item => {\n      if (item.frozen) {\n        usedWidth += item.targetMainSize;\n      } else {\n        usedWidth += item.baseSize;\n        flexFactors += item.flex;\n      }\n    });\n\n    let remainingFreeSpace = availableWidth - usedWidth;\n    // we only support integer FR's, and because of hasNonFrozenItems, we know that flexFactors > 0\n    // so no need to check for flexFactors < 1\n    // 9.7.4.c\n    /**\n     * If the remaining free space is zero\n     * - Do nothing.\n     * Else // remember, we're always in grow mode\n     * - Find the ratio of the item’s flex grow factor to the\n     * sum of the flex grow factors of all unfrozen items on\n     * the line. Set the item’s target main size to its flex\n     * base size plus a fraction of the remaining free space\n     * proportional to the ratio.\n     */\n    if (remainingFreeSpace > 0) {\n      flexItems.forEach((item) => {\n        if (!item.frozen) {\n          let ratio = item.flex / flexFactors;\n          item.targetMainSize = item.baseSize + (ratio * remainingFreeSpace);\n        }\n      });\n    }\n\n    // 9.7.4.d\n    /**\n     * Fix min/max violations. Clamp each non-frozen item’s\n     * target main size by its used min and max main sizes\n     * and floor its content-box size at zero. If the item’s\n     * target main size was made smaller by this, it’s a max\n     * violation. If the item’s target main size was made\n     * larger by this, it’s a min violation.\n     */\n    let totalViolation = 0;\n    flexItems.forEach(item => {\n      item.violation = 0;\n      if (!item.frozen) {\n        let {min, max, targetMainSize} = item;\n        item.targetMainSize = Math.max(min, Math.min(targetMainSize, max));\n\n        item.violation = item.targetMainSize - targetMainSize;\n        totalViolation += item.violation;\n      }\n    });\n\n    // 9.7.4.e\n    /**\n     * Freeze over-flexed items. The total violation is the\n     * sum of the adjustments from the previous step\n     * ∑(clamped size - unclamped size). If the total violation is:\n     * Zero\n     * - Freeze all items.\n     *\n     * Positive\n     * - Freeze all the items with min violations.\n     *\n     * Negative\n     * - Freeze all the items with max violations.\n     */\n    hasNonFrozenItems = false;\n    flexItems.forEach(item => {\n      if (totalViolation === 0 || Math.sign(totalViolation) === Math.sign(item.violation)) {\n        item.frozen = true;\n      } else if (!item.frozen) {\n        hasNonFrozenItems = true;\n      }\n    });\n  }\n\n  return cascadeRounding(flexItems);\n}\n\nfunction cascadeRounding(flexItems): number[] {\n  /*\n  Given an array of floats that sum to an integer, this rounds the floats\n  and returns an array of integers with the same sum.\n  */\n\n  let fpTotal = 0;\n  let intTotal = 0;\n  let roundedArray = [];\n  flexItems.forEach(function (item) {\n    let float = item.targetMainSize;\n    let integer = Math.round(float + fpTotal) - intTotal;\n    fpTotal += float;\n    intTotal += integer;\n    roundedArray.push(integer);\n  });\n\n  return roundedArray;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {GridState, useGridState} from '@react-stately/grid';\nimport {TableCollection as ITableCollection, TableBodyProps, TableHeaderProps} from '@react-types/table';\nimport {Key, Node, SelectionMode, Sortable, SortDescriptor, SortDirection} from '@react-types/shared';\nimport {MultipleSelectionStateProps} from '@react-stately/selection';\nimport {ReactElement, useCallback, useMemo, useState} from 'react';\nimport {TableCollection} from './TableCollection';\nimport {useCollection} from '@react-stately/collections';\n\nexport interface TableState<T> extends GridState<T, ITableCollection<T>> {\n  /** A collection of rows and columns in the table. */\n  collection: ITableCollection<T>,\n  /** Whether the row selection checkboxes should be displayed. */\n  showSelectionCheckboxes: boolean,\n  /** The current sorted column and direction. */\n  sortDescriptor: SortDescriptor,\n  /** Calls the provided onSortChange handler with the provided column key and sort direction. */\n  sort(columnKey: Key, direction?: 'ascending' | 'descending'): void,\n  /** Whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. */\n  isKeyboardNavigationDisabled: boolean,\n  /** Set whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. */\n  setKeyboardNavigationDisabled: (val: boolean) => void\n}\n\nexport interface CollectionBuilderContext<T> {\n  showSelectionCheckboxes: boolean,\n  showDragButtons: boolean,\n  selectionMode: SelectionMode,\n  columns: Node<T>[]\n}\n\nexport interface TableStateProps<T> extends MultipleSelectionStateProps, Sortable {\n  /** The elements that make up the table. Includes the TableHeader, TableBody, Columns, and Rows. */\n  children?: [ReactElement<TableHeaderProps<T>>, ReactElement<TableBodyProps<T>>],\n  /** A list of row keys to disable. */\n  disabledKeys?: Iterable<Key>,\n  /** A pre-constructed collection to use instead of building one from items and children. */\n  collection?: ITableCollection<T>,\n  /** Whether the row selection checkboxes should be displayed. */\n  showSelectionCheckboxes?: boolean,\n  /** Whether the row drag button should be displayed.\n   * @private\n   */\n  showDragButtons?: boolean\n}\n\nconst OPPOSITE_SORT_DIRECTION = {\n  ascending: 'descending' as SortDirection,\n  descending: 'ascending' as SortDirection\n};\n\n/**\n * Provides state management for a table component. Handles building a collection\n * of columns and rows from props. In addition, it tracks row selection and manages sort order changes.\n */\nexport function useTableState<T extends object>(props: TableStateProps<T>): TableState<T> {\n  let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = useState(false);\n  let {selectionMode = 'none', showSelectionCheckboxes, showDragButtons} = props;\n\n  let context = useMemo(() => ({\n    showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== 'none',\n    showDragButtons: showDragButtons,\n    selectionMode,\n    columns: []\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }), [props.children, showSelectionCheckboxes, selectionMode, showDragButtons]);\n\n  let collection = useCollection<T, ITableCollection<T>>(\n    props,\n    useCallback((nodes) => new TableCollection(nodes, null, context), [context]),\n    context\n  );\n  let {disabledKeys, selectionManager} = useGridState({\n    ...props,\n    collection,\n    disabledBehavior: props.disabledBehavior || 'selection'\n  });\n\n  return {\n    collection,\n    disabledKeys,\n    selectionManager,\n    showSelectionCheckboxes: props.showSelectionCheckboxes || false,\n    sortDescriptor: props.sortDescriptor,\n    isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,\n    setKeyboardNavigationDisabled,\n    sort(columnKey: Key, direction?: 'ascending' | 'descending') {\n      props.onSortChange({\n        column: columnKey,\n        direction: direction ?? (props.sortDescriptor?.column === columnKey\n          ? OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction]\n          : 'ascending')\n      });\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getFirstItem, getLastItem} from '@react-stately/collections';\nimport {GridCollection} from '@react-stately/grid';\nimport {GridNode} from '@react-types/grid';\nimport {TableCollection as ITableCollection} from '@react-types/table';\nimport {Key} from '@react-types/shared';\n\ninterface GridCollectionOptions {\n  showSelectionCheckboxes?: boolean,\n  showDragButtons?: boolean\n}\n\nconst ROW_HEADER_COLUMN_KEY = 'row-header-column-' + Math.random().toString(36).slice(2);\nlet ROW_HEADER_COLUMN_KEY_DRAG = 'row-header-column-' + Math.random().toString(36).slice(2);\nwhile (ROW_HEADER_COLUMN_KEY === ROW_HEADER_COLUMN_KEY_DRAG) {\n  ROW_HEADER_COLUMN_KEY_DRAG = 'row-header-column-' + Math.random().toString(36).slice(2);\n}\n\n/** @private */\nexport function buildHeaderRows<T>(keyMap: Map<Key, GridNode<T>>, columnNodes: GridNode<T>[]): GridNode<T>[] {\n  if (columnNodes.length === 0) {\n    return [];\n  }\n\n  let columns: GridNode<T>[][] = [];\n  let seen = new Map();\n  for (let column of columnNodes) {\n    let parentKey = column.parentKey;\n    let col = [column];\n\n    while (parentKey) {\n      let parent: GridNode<T> = keyMap.get(parentKey);\n      if (!parent) {\n        break;\n      }\n\n      // If we've already seen this parent, than it is shared\n      // with a previous column. If the current column is taller\n      // than the previous column, than we need to shift the parent\n      // in the previous column so it's level with the current column.\n      if (seen.has(parent)) {\n        parent.colspan++;\n\n        let {column, index} = seen.get(parent);\n        if (index > col.length) {\n          break;\n        }\n\n        for (let i = index; i < col.length; i++) {\n          column.splice(i, 0, null);\n        }\n\n        // Adjust shifted indices\n        for (let i = col.length; i < column.length; i++) {\n          // eslint-disable-next-line max-depth\n          if (column[i] && seen.has(column[i])) {\n            seen.get(column[i]).index = i;\n          }\n        }\n      } else {\n        parent.colspan = 1;\n        col.push(parent);\n        seen.set(parent, {column: col, index: col.length - 1});\n      }\n\n      parentKey = parent.parentKey;\n    }\n\n    columns.push(col);\n    column.index = columns.length - 1;\n  }\n\n  let maxLength = Math.max(...columns.map(c => c.length));\n  let headerRows = Array(maxLength).fill(0).map(() => []);\n\n  // Convert columns into rows.\n  let colIndex = 0;\n  for (let column of columns) {\n    let i = maxLength - 1;\n    for (let item of column) {\n      if (item) {\n        // Fill the space up until the current column with a placeholder\n        let row = headerRows[i];\n        let rowLength = row.reduce((p, c) => p + c.colspan, 0);\n        if (rowLength < colIndex) {\n          let placeholder: GridNode<T> = {\n            type: 'placeholder',\n            key: 'placeholder-' + item.key,\n            colspan: colIndex - rowLength,\n            index: rowLength,\n            value: null,\n            rendered: null,\n            level: i,\n            hasChildNodes: false,\n            childNodes: [],\n            textValue: null\n          };\n\n          // eslint-disable-next-line max-depth\n          if (row.length > 0) {\n            row[row.length - 1].nextKey = placeholder.key;\n            placeholder.prevKey = row[row.length - 1].key;\n          }\n\n          row.push(placeholder);\n        }\n\n        if (row.length > 0) {\n          row[row.length - 1].nextKey = item.key;\n          item.prevKey = row[row.length - 1].key;\n        }\n\n        item.level = i;\n        item.colIndex = colIndex;\n        row.push(item);\n      }\n\n      i--;\n    }\n\n    colIndex++;\n  }\n\n  // Add placeholders at the end of each row that is shorter than the maximum\n  let i = 0;\n  for (let row of headerRows) {\n    let rowLength = row.reduce((p, c) => p + c.colspan, 0);\n    if (rowLength < columnNodes.length) {\n      let placeholder: GridNode<T> = {\n        type: 'placeholder',\n        key: 'placeholder-' + row[row.length - 1].key,\n        colspan: columnNodes.length - rowLength,\n        index: rowLength,\n        value: null,\n        rendered: null,\n        level: i,\n        hasChildNodes: false,\n        childNodes: [],\n        textValue: null,\n        prevKey: row[row.length - 1].key\n      };\n\n      row.push(placeholder);\n    }\n\n    i++;\n  }\n\n  return headerRows.map((childNodes, index) => {\n    let row: GridNode<T> = {\n      type: 'headerrow',\n      key: 'headerrow-' + index,\n      index,\n      value: null,\n      rendered: null,\n      level: 0,\n      hasChildNodes: true,\n      childNodes,\n      textValue: null\n    };\n\n    return row;\n  });\n}\n\nexport class TableCollection<T> extends GridCollection<T> implements ITableCollection<T> {\n  headerRows: GridNode<T>[];\n  columns: GridNode<T>[];\n  rowHeaderColumnKeys: Set<Key>;\n  body: GridNode<T>;\n  _size: number = 0;\n\n  constructor(nodes: Iterable<GridNode<T>>, prev?: ITableCollection<T>, opts?: GridCollectionOptions) {\n    let rowHeaderColumnKeys: Set<Key> = new Set();\n    let body: GridNode<T>;\n    let columns: GridNode<T>[] = [];\n    // Add cell for selection checkboxes if needed.\n    if (opts?.showSelectionCheckboxes) {\n      let rowHeaderColumn: GridNode<T> = {\n        type: 'column',\n        key: ROW_HEADER_COLUMN_KEY,\n        value: null,\n        textValue: '',\n        level: 0,\n        index: opts?.showDragButtons ? 1 : 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isSelectionCell: true\n        }\n      };\n\n      columns.unshift(rowHeaderColumn);\n    }\n\n    // Add cell for drag buttons if needed.\n    if (opts?.showDragButtons) {\n      let rowHeaderColumn: GridNode<T> = {\n        type: 'column',\n        key: ROW_HEADER_COLUMN_KEY_DRAG,\n        value: null,\n        textValue: '',\n        level: 0,\n        index: 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isDragButtonCell: true\n        }\n      };\n\n      columns.unshift(rowHeaderColumn);\n    }\n\n    let rows = [];\n    let columnKeyMap = new Map();\n    let visit = (node: GridNode<T>) => {\n      switch (node.type) {\n        case 'body':\n          body = node;\n          break;\n        case 'column':\n          columnKeyMap.set(node.key, node);\n          if (!node.hasChildNodes) {\n            columns.push(node);\n\n            if (node.props.isRowHeader) {\n              rowHeaderColumnKeys.add(node.key);\n            }\n          }\n          break;\n        case 'item':\n          rows.push(node);\n          return; // do not go into childNodes\n      }\n      for (let child of node.childNodes) {\n        visit(child);\n      }\n    };\n\n    for (let node of nodes) {\n      visit(node);\n    }\n\n    let headerRows = buildHeaderRows(columnKeyMap, columns) as GridNode<T>[];\n    headerRows.forEach((row, i) => rows.splice(i, 0, row));\n\n    super({\n      columnCount: columns.length,\n      items: rows,\n      visitNode: node => {\n        node.column = columns[node.index];\n        return node;\n      }\n    });\n    this.columns = columns;\n    this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n    this.body = body;\n    this.headerRows = headerRows;\n    this._size = [...body.childNodes].length;\n\n    // Default row header column to the first one.\n    if (this.rowHeaderColumnKeys.size === 0) {\n      if (opts?.showSelectionCheckboxes) {\n        if (opts?.showDragButtons) {\n          this.rowHeaderColumnKeys.add(this.columns[2].key);\n        } else {\n          this.rowHeaderColumnKeys.add(this.columns[1].key);\n        }\n      } else {\n        this.rowHeaderColumnKeys.add(this.columns[0].key);\n      }\n    }\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.body.childNodes;\n  }\n\n  get size() {\n    return this._size;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return getFirstItem(this.body.childNodes)?.key;\n  }\n\n  getLastKey() {\n    return getLastItem(this.body.childNodes)?.key;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n\n  getTextValue(key: Key): string {\n    let row = this.getItem(key);\n    if (!row) {\n      return '';\n    }\n\n    // If the row has a textValue, use that.\n    if (row.textValue) {\n      return row.textValue;\n    }\n\n    // Otherwise combine the text of each of the row header columns.\n    let rowHeaderColumnKeys = this.rowHeaderColumnKeys;\n    if (rowHeaderColumnKeys) {\n      let text = [];\n      for (let cell of row.childNodes) {\n        let column = this.columns[cell.index];\n        if (rowHeaderColumnKeys.has(column.key) && cell.textValue) {\n          text.push(cell.textValue);\n        }\n\n        if (text.length === rowHeaderColumnKeys.size) {\n          break;\n        }\n      }\n\n      return text.join(' ');\n    }\n\n    return '';\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBuilderContext} from './useTableState';\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\nimport {TableHeaderProps} from '@react-types/table';\n\nfunction TableHeader<T>(props: TableHeaderProps<T>): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nTableHeader.getCollectionNode = function* getCollectionNode<T>(props: TableHeaderProps<T>, context: CollectionBuilderContext<T>): Generator<PartialNode<T>, void, any> {\n  let {children, columns} = props;\n\n  // Clear columns so they aren't double added in strict mode.\n  context.columns = [];\n\n  if (typeof children === 'function') {\n    if (!columns) {\n      throw new Error('props.children was a function but props.columns is missing');\n    }\n\n    for (let column of columns) {\n      yield {\n        type: 'column',\n        value: column,\n        renderer: children\n      };\n    }\n  } else {\n    let columns: PartialNode<T>[] = [];\n    React.Children.forEach(children, column => {\n      columns.push({\n        type: 'column',\n        element: column\n      });\n    });\n\n    yield* columns;\n  }\n};\n\n/**\n * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `columns` prop.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _TableHeader = TableHeader as <T>(props: TableHeaderProps<T>) => React.JSX.Element;\nexport {_TableHeader as TableHeader};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\nimport {TableBodyProps} from '@react-types/table';\n\nfunction TableBody<T>(props: TableBodyProps<T>): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nTableBody.getCollectionNode = function* getCollectionNode<T>(props: TableBodyProps<T>): Generator<PartialNode<T>> {\n  let {children, items} = props;\n  yield {\n    type: 'body',\n    hasChildNodes: true,\n    props,\n    *childNodes() {\n      if (typeof children === 'function') {\n        if (!items) {\n          throw new Error('props.children was a function but props.items is missing');\n        }\n\n        for (let item of items) {\n          yield {\n            type: 'item',\n            value: item,\n            renderer: children\n          };\n        }\n      } else {\n        let items: PartialNode<T>[] = [];\n        React.Children.forEach(children, item => {\n          items.push({\n            type: 'item',\n            element: item\n          });\n        });\n\n        yield* items;\n      }\n    }\n  };\n};\n\n/**\n * A TableBody is a container for the Row elements of a Table. Rows can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `items` prop.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _TableBody = TableBody as <T>(props: TableBodyProps<T>) => React.JSX.Element;\nexport {_TableBody as TableBody};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBuilderContext} from './useTableState';\nimport {ColumnProps} from '@react-types/table';\nimport {GridNode} from '@react-types/grid';\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\n\nfunction Column<T>(props: ColumnProps<T>): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nColumn.getCollectionNode = function* getCollectionNode<T>(props: ColumnProps<T>, context: CollectionBuilderContext<T>): Generator<PartialNode<T>, void, GridNode<T>[]> {\n  let {title, children, childColumns} = props;\n\n  let rendered = title || children;\n  let textValue = props.textValue || (typeof rendered === 'string' ? rendered : '') || props['aria-label'];\n\n  let fullNodes = yield {\n    type: 'column',\n    hasChildNodes: !!childColumns || (title && React.Children.count(children) > 0),\n    rendered,\n    textValue,\n    props,\n    *childNodes() {\n      if (childColumns) {\n        for (let child of childColumns) {\n          yield {\n            type: 'column',\n            value: child\n          };\n        }\n      } else if (title) {\n        let childColumns: PartialNode<T>[] = [];\n        React.Children.forEach(children, child => {\n          childColumns.push({\n            type: 'column',\n            element: child as ReactElement<ColumnProps<T>>\n          });\n        });\n\n        yield* childColumns;\n      }\n    },\n    shouldInvalidate(newContext: CollectionBuilderContext<T>) {\n      // This is a bit of a hack, but it works.\n      // If this method is called, then there's a cached version of this node available.\n      // But, we need to keep the list of columns in the new context up to date.\n      updateContext(newContext);\n      return false;\n    }\n  };\n\n  let updateContext = (context: CollectionBuilderContext<T>) => {\n    // register leaf columns on the context so that <Row> can access them\n    for (let node of fullNodes) {\n      if (!node.hasChildNodes) {\n        context.columns.push(node);\n      }\n    }\n  };\n\n  updateContext(context);\n};\n\n/**\n * A Column represents a field of each item within a Table. Columns may also contain nested\n * Column elements to represent column groups. Nested columns can be statically defined as\n * children, or dynamically generated using a function based on the `childColumns` prop.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _Column = Column as <T>(props: ColumnProps<T>) => React.JSX.Element;\nexport {_Column as Column};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBuilderContext} from './useTableState';\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\nimport {RowProps} from '@react-types/table';\n\nfunction Row<T>(props: RowProps<T>): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nRow.getCollectionNode = function* getCollectionNode<T>(props: RowProps<T>, context: CollectionBuilderContext<T>): Generator<PartialNode<T>> {\n  let {children, textValue, UNSTABLE_childItems} = props;\n\n  yield {\n    type: 'item',\n    props: props,\n    textValue,\n    'aria-label': props['aria-label'],\n    hasChildNodes: true,\n    *childNodes() {\n      // Process cells first\n      if (context.showDragButtons) {\n        yield {\n          type: 'cell',\n          key: 'header-drag', // this is combined with the row key by CollectionBuilder\n          props: {\n            isDragButtonCell: true\n          }\n        };\n      }\n\n      if (context.showSelectionCheckboxes && context.selectionMode !== 'none') {\n        yield {\n          type: 'cell',\n          key: 'header', // this is combined with the row key by CollectionBuilder\n          props: {\n            isSelectionCell: true\n          }\n        };\n      }\n\n      if (typeof children === 'function') {\n        for (let column of context.columns) {\n          yield {\n            type: 'cell',\n            element: children(column.key),\n            key: column.key // this is combined with the row key by CollectionBuilder\n          };\n        }\n\n        if (UNSTABLE_childItems) {\n          for (let child of UNSTABLE_childItems) {\n            // Note: in order to reuse the render function of TableBody for our child rows, we just need to yield a type and a value here. CollectionBuilder will then look up\n            // the parent renderer and use that to build the full node of this child row, using the value provided here to generate the cells\n            yield {\n              type: 'item',\n              value: child\n            };\n          }\n        }\n      } else {\n        let cells: PartialNode<T>[] = [];\n        let childRows: PartialNode<T>[] = [];\n        React.Children.forEach(children, node => {\n          if (node.type === Row) {\n            if (cells.length < context.columns.length) {\n              throw new Error('All of a Row\\'s child Cells must be positioned before any child Rows.');\n            }\n\n            childRows.push({\n              type: 'item',\n              element: node\n            });\n          } else {\n            cells.push({\n              type: 'cell',\n              element: node\n            });\n          }\n        });\n\n        if (cells.length !== context.columns.length) {\n          throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);\n        }\n\n        yield* cells;\n        yield* childRows;\n      }\n    },\n    shouldInvalidate(newContext: CollectionBuilderContext<T>) {\n      // Invalidate all rows if the columns changed.\n      return newContext.columns.length !== context.columns.length ||\n        newContext.columns.some((c, i) => c.key !== context.columns[i].key) ||\n        newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes ||\n        newContext.showDragButtons !== context.showDragButtons ||\n        newContext.selectionMode !== context.selectionMode;\n    }\n  };\n};\n\n/**\n * A Row represents a single item in a Table and contains Cell elements for each column.\n * Cells can be statically defined as children, or generated dynamically using a function\n * based on the columns defined in the TableHeader.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _Row = Row as <T>(props: RowProps<T>) => React.JSX.Element;\nexport {_Row as Row};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CellProps} from '@react-types/table';\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\n\nfunction Cell(props: CellProps): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nCell.getCollectionNode = function* getCollectionNode<T>(props: CellProps): Generator<PartialNode<T>> {\n  let {children} = props;\n\n  let textValue = props.textValue || (typeof children === 'string' ? children : '') || props['aria-label'] || '';\n  yield {\n    type: 'cell',\n    props: props,\n    rendered: children,\n    textValue,\n    'aria-label': props['aria-label'],\n    hasChildNodes: false\n  };\n};\n\n/**\n * A Cell represents the value of a single Column within a Table Row.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _Cell = Cell as (props: CellProps) => React.JSX.Element;\nexport {_Cell as Cell};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBuilder} from '@react-stately/collections';\nimport {GridNode} from '@react-types/grid';\nimport {Key} from '@react-types/shared';\nimport {ReactElement, useMemo} from 'react';\nimport {TableCollection} from './TableCollection';\nimport {tableNestedRows} from '@react-stately/flags';\nimport {TableState, TableStateProps, useTableState} from './useTableState';\nimport {useControlledState} from '@react-stately/utils';\n\nexport interface TreeGridState<T> extends TableState<T> {\n  /** A set of keys for items that are expanded. */\n  expandedKeys: 'all' | Set<Key>,\n  /** Toggles the expanded state for a row by its key. */\n  toggleKey(key: Key): void,\n  /** The key map containing nodes representing the collection's tree grid structure. */\n  keyMap: Map<Key, GridNode<T>>,\n  /** The number of leaf columns provided by the user. */\n  userColumnCount: number\n}\n\nexport interface TreeGridStateProps<T> extends Omit<TableStateProps<T>, 'collection'> {\n  /** The currently expanded keys in the collection (controlled). */\n  UNSTABLE_expandedKeys?: 'all' | Iterable<Key>,\n  /** The initial expanded keys in the collection (uncontrolled). */\n  UNSTABLE_defaultExpandedKeys?: 'all' | Iterable<Key>,\n  /** Handler that is called when items are expanded or collapsed. */\n  UNSTABLE_onExpandedChange?: (keys: Set<Key>) => any\n}\n\n/**\n * Provides state management for a tree grid component. Handles building a collection\n * of columns and rows from props. In addition, it tracks and manages expanded rows, row selection, and sort order changes.\n */\nexport function UNSTABLE_useTreeGridState<T extends object>(props: TreeGridStateProps<T>): TreeGridState<T> {\n  let {\n    selectionMode = 'none',\n    showSelectionCheckboxes,\n    showDragButtons,\n    UNSTABLE_expandedKeys: propExpandedKeys,\n    UNSTABLE_defaultExpandedKeys: propDefaultExpandedKeys,\n    UNSTABLE_onExpandedChange,\n    children\n  } = props;\n\n  if (!tableNestedRows()) {\n    throw new Error('Feature flag for table nested rows must be enabled to use useTreeGridState.');\n  }\n\n  let [expandedKeys, setExpandedKeys] = useControlledState(\n    propExpandedKeys ? convertExpanded(propExpandedKeys) : undefined,\n    propDefaultExpandedKeys ? convertExpanded(propDefaultExpandedKeys) : new Set(),\n    UNSTABLE_onExpandedChange\n  );\n\n  let context = useMemo(() => ({\n    showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== 'none',\n    showDragButtons: showDragButtons,\n    selectionMode,\n    columns: []\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }), [children, showSelectionCheckboxes, selectionMode, showDragButtons]);\n\n  let builder = useMemo(() => new CollectionBuilder<T>(), []);\n  let nodes = useMemo(() => builder.build({children: children as ReactElement[]}, context), [builder, children, context]);\n  let treeGridCollection = useMemo(() => {\n    return generateTreeGridCollection<T>(nodes, {showSelectionCheckboxes, showDragButtons, expandedKeys});\n  }, [nodes, showSelectionCheckboxes, showDragButtons, expandedKeys]);\n\n  let onToggle = (key: Key) => {\n    setExpandedKeys(toggleKey(expandedKeys, key, treeGridCollection));\n  };\n\n  let collection = useMemo(() => {\n    return new TableCollection(treeGridCollection.tableNodes, null, context);\n  }, [context, treeGridCollection.tableNodes]);\n\n  let tableState = useTableState({...props, collection});\n  return {\n    ...tableState,\n    keyMap: treeGridCollection.keyMap,\n    userColumnCount: treeGridCollection.userColumnCount,\n    expandedKeys,\n    toggleKey: onToggle\n  };\n}\n\nfunction toggleKey<T>(currentExpandedKeys: 'all' | Set<Key>, key: Key, collection: TreeGridCollection<T>): Set<Key> {\n  let updatedExpandedKeys: Set<Key>;\n  if (currentExpandedKeys === 'all') {\n    updatedExpandedKeys = new Set(collection.flattenedRows.filter(row => row.props.UNSTABLE_childItems || row.props.children.length > collection.userColumnCount).map(row => row.key));\n    updatedExpandedKeys.delete(key);\n  } else {\n    updatedExpandedKeys = new Set(currentExpandedKeys);\n    if (updatedExpandedKeys.has(key)) {\n      updatedExpandedKeys.delete(key);\n    } else {\n      updatedExpandedKeys.add(key);\n    }\n  }\n\n  return updatedExpandedKeys;\n}\n\nfunction convertExpanded(expanded: 'all' | Iterable<Key>): 'all' | Set<Key> {\n  if (!expanded) {\n    return new Set<Key>();\n  }\n\n  return expanded === 'all'\n    ? 'all'\n    : new Set(expanded);\n}\n\ninterface TreeGridCollectionOptions {\n  showSelectionCheckboxes?: boolean,\n  showDragButtons?: boolean,\n  expandedKeys: 'all' | Set<Key>\n}\n\ninterface TreeGridCollection<T> {\n  keyMap: Map<Key, GridNode<T>>,\n  tableNodes: GridNode<T>[],\n  flattenedRows: GridNode<T>[],\n  userColumnCount: number\n}\nfunction generateTreeGridCollection<T>(nodes, opts: TreeGridCollectionOptions): TreeGridCollection<T> {\n  let {\n    expandedKeys = new Set()\n  } = opts;\n\n  let body: GridNode<T>;\n  let flattenedRows = [];\n  let columnCount = 0;\n  let userColumnCount = 0;\n  let originalColumns = [];\n  let keyMap = new Map();\n\n  if (opts?.showSelectionCheckboxes) {\n    columnCount++;\n  }\n\n  if (opts?.showDragButtons) {\n    columnCount++;\n  }\n\n  let topLevelRows = [];\n  let visit = (node: GridNode<T>) => {\n    switch (node.type) {\n      case 'body':\n        body = node;\n        keyMap.set(body.key, body);\n        break;\n      case 'column':\n        if (!node.hasChildNodes) {\n          userColumnCount++;\n        }\n        break;\n      case 'item':\n        topLevelRows.push(node);\n        return;\n    }\n\n    for (let child of node.childNodes) {\n      visit(child);\n    }\n  };\n\n  for (let node of nodes) {\n    if (node.type === 'column') {\n      originalColumns.push(node);\n    }\n    visit(node);\n  }\n  columnCount += userColumnCount;\n\n  // Update each grid node in the treegrid table with values specific to a treegrid structure. Also store a set of flattened row nodes for TableCollection to consume\n  let globalRowCount = 0;\n  let visitNode = (node: GridNode<T>, i?: number) => {\n    // Clone row node and its children so modifications to the node for treegrid specific values aren't applied on the nodes provided\n    // to TableCollection. Index, level, and parent keys are all changed to reflect a flattened row structure rather than the treegrid structure\n    // values automatically calculated via CollectionBuilder\n    if (node.type === 'item') {\n      let childNodes = [];\n      for (let child of node.childNodes) {\n        if (child.type === 'cell') {\n          let cellClone = {...child};\n          if (cellClone.index + 1 === columnCount) {\n            cellClone.nextKey = null;\n          }\n          childNodes.push({...cellClone});\n        }\n      }\n      let clone = {...node, childNodes: childNodes, parentKey: body.key, level: 1, index: globalRowCount++};\n      flattenedRows.push(clone);\n    }\n\n    let newProps = {};\n\n    // Assign indexOfType to cells and rows for aria-posinset\n    if (node.type !== 'placeholder' && node.type !== 'column') {\n      newProps['indexOfType'] = i;\n    }\n\n    // Use Object.assign instead of spread to preserve object reference for keyMap. Also ensures retrieving nodes\n    // via .childNodes returns the same object as the one found via keyMap look up\n    Object.assign(node, newProps);\n    keyMap.set(node.key, node);\n\n    let lastNode: GridNode<T>;\n    let rowIndex = 0;\n    for (let child of node.childNodes) {\n      if (!(child.type === 'item' && expandedKeys !== 'all' && !expandedKeys.has(node.key))) {\n        if (child.parentKey == null) {\n          // if child is a cell/expanded row/column and the parent key isn't already established by the collection, match child node to parent row\n          child.parentKey = node.key;\n        }\n\n        if (lastNode) {\n          lastNode.nextKey = child.key;\n          child.prevKey = lastNode.key;\n        } else {\n          child.prevKey = null;\n        }\n\n        if (child.type === 'item') {\n          visitNode(child, rowIndex++);\n        } else {\n          // We enforce that the cells come before rows so can just reuse cell index\n          visitNode(child, child.index);\n        }\n\n        lastNode = child;\n      }\n    }\n\n    if (lastNode) {\n      lastNode.nextKey = null;\n    }\n  };\n\n  let last: GridNode<T>;\n  topLevelRows.forEach((node: GridNode<T>, i) => {\n    visitNode(node as GridNode<T>, i);\n\n    if (last) {\n      last.nextKey = node.key;\n      node.prevKey = last.key;\n    } else {\n      node.prevKey = null;\n    }\n\n    last = node;\n  });\n\n  if (last) {\n    last.nextKey = null;\n  }\n\n  return {\n    keyMap,\n    userColumnCount,\n    flattenedRows,\n    tableNodes: [...originalColumns, {...body, childNodes: flattenedRows}]\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}